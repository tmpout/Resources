
<!DOCTYPE html>
<html lang="en-US">
<head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app210.us.archive.org';v.server_ms=486;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="/_static/js/bundle-playback.js?v=rQCmsv02" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=UHAOicsW" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("https://man7.org/linux/man-pages/man5/elf.5.html","20210330083236","https://web.archive.org/","web","/_static/",
	      "1617093156");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=fantwOh2" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>elf(5) - Linux manual page</title>
    <link rel="stylesheet" type="text/css" href="/web/20210330083236cs_/https://man7.org/style.css" title="style"/>
    <link rel="stylesheet" type="text/css" href="/web/20210330083236cs_/https://man7.org/linux/man-pages/style.css" title="style"/>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="/web/20210330083236/https://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="/web/20210330083236/https://man7.org/linux/man-pages/index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="https://web.archive.org/web/20210330083236/http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end"/>

<!--%%%PAGE_START%%%-->
<h1>elf(5) &mdash; Linux manual page</h1>


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#NOTES">NOTES</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
</tr>
<tr>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="https://web.archive.org/web/20210330083236/https://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value=""/>
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages"/>
                    <input type="submit" name="sa" value="Search online pages"/>
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">ELF(5)                  Linux Programmer's Manual                 ELF(5)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       elf - format of Executable and Linking Format (ELF) files
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>#include &lt;elf.h&gt;</b>
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The header file <i>&lt;elf.h&gt;</i> defines the format of ELF executable
       binary files.  Amongst these files are normal executable files,
       relocatable object files, core files, and shared objects.

       An executable file using the ELF file format consists of an ELF
       header, followed by a program header table or a section header
       table, or both.  The ELF header is always at offset zero of the
       file.  The program header table and the section header table's
       offset in the file are defined in the ELF header.  The two tables
       describe the rest of the particularities of the file.

       This header file describes the above mentioned headers as C
       structures and also includes structures for dynamic sections,
       relocation sections and symbol tables.

   <b>Basic types</b>
       The following types are used for N-bit architectures (N=32,64,
       <i>ElfN</i> stands for <i>Elf32</i> or <i>Elf64</i>, <i>uintN_t</i> stands for <i>uint32_t</i> or
       <i>uint64_t</i>):

           ElfN_Addr       Unsigned program address, uintN_t
           ElfN_Off        Unsigned file offset, uintN_t
           ElfN_Section    Unsigned section index, uint16_t
           ElfN_Versym     Unsigned version symbol information, uint16_t
           Elf_Byte        unsigned char
           ElfN_Half       uint16_t
           ElfN_Sword      int32_t
           ElfN_Word       uint32_t
           ElfN_Sxword     int64_t
           ElfN_Xword      uint64_t

       (Note: the *BSD terminology is a bit different.  There,
       <i>Elf64_Half</i> is twice as large as <i>Elf32_Half</i>, and <i>Elf64Quarter</i> is
       used for <i>uint16_t</i>.  In order to avoid confusion these types are
       replaced by explicit ones in the below.)

       All data structures that the file format defines follow the
       "natural" size and alignment guidelines for the relevant class.
       If necessary, data structures contain explicit padding to ensure
       4-byte alignment for 4-byte objects, to force structure sizes to
       a multiple of 4, and so on.

   <b>ELF header (Ehdr)</b>
       The ELF header is described by the type <i>Elf32_Ehdr</i> or <i>Elf64_Ehdr</i>:

           #define EI_NIDENT 16

           typedef struct {
               unsigned char e_ident[EI_NIDENT];
               uint16_t      e_type;
               uint16_t      e_machine;
               uint32_t      e_version;
               ElfN_Addr     e_entry;
               ElfN_Off      e_phoff;
               ElfN_Off      e_shoff;
               uint32_t      e_flags;
               uint16_t      e_ehsize;
               uint16_t      e_phentsize;
               uint16_t      e_phnum;
               uint16_t      e_shentsize;
               uint16_t      e_shnum;
               uint16_t      e_shstrndx;
           } ElfN_Ehdr;

       The fields have the following meanings:

       <i>e_ident</i>
              This array of bytes specifies how to interpret the file,
              independent of the processor or the file's remaining
              contents.  Within this array everything is named by
              macros, which start with the prefix <b>EI_ </b>and may contain
              values which start with the prefix <b>ELF</b>.  The following
              macros are defined:

              <b>EI_MAG0</b>
                     The first byte of the magic number.  It must be
                     filled with <b>ELFMAG0</b>.  (0: 0x7f)

              <b>EI_MAG1</b>
                     The second byte of the magic number.  It must be
                     filled with <b>ELFMAG1</b>.  (1: 'E')

              <b>EI_MAG2</b>
                     The third byte of the magic number.  It must be
                     filled with <b>ELFMAG2</b>.  (2: 'L')

              <b>EI_MAG3</b>
                     The fourth byte of the magic number.  It must be
                     filled with <b>ELFMAG3</b>.  (3: 'F')

              <b>EI_CLASS</b>
                     The fifth byte identifies the architecture for this
                     binary:

                     <b>ELFCLASSNONE</b>
                            This class is invalid.
                     <b>ELFCLASS32</b>
                            This defines the 32-bit architecture.  It
                            supports machines with files and virtual
                            address spaces up to 4 Gigabytes.
                     <b>ELFCLASS64</b>
                            This defines the 64-bit architecture.

              <b>EI_DATA</b>
                     The sixth byte specifies the data encoding of the
                     processor-specific data in the file.  Currently,
                     these encodings are supported:

                       <b>ELFDATANONE</b>
                              Unknown data format.
                       <b>ELFDATA2LSB</b>
                              Two's complement, little-endian.
                       <b>ELFDATA2MSB</b>
                              Two's complement, big-endian.

              <b>EI_VERSION</b>
                     The seventh byte is the version number of the ELF
                     specification:

                     <b>EV_NONE</b>
                            Invalid version.
                     <b>EV_CURRENT</b>
                            Current version.

              <b>EI_OSABI</b>
                     The eighth byte identifies the operating system and
                     ABI to which the object is targeted.  Some fields
                     in other ELF structures have flags and values that
                     have platform-specific meanings; the interpretation
                     of those fields is determined by the value of this
                     byte.  For example:

                     <b>ELFOSABI_NONE</b>
                            Same as ELFOSABI_SYSV
                     <b>ELFOSABI_SYSV</b>
                            UNIX System V ABI
                     <b>ELFOSABI_HPUX</b>
                            HP-UX ABI
                     <b>ELFOSABI_NETBSD</b>
                            NetBSD ABI
                     <b>ELFOSABI_LINUX</b>
                            Linux ABI
                     <b>ELFOSABI_SOLARIS</b>
                            Solaris ABI
                     <b>ELFOSABI_IRIX</b>
                            IRIX ABI
                     <b>ELFOSABI_FREEBSD</b>
                            FreeBSD ABI
                     <b>ELFOSABI_TRU64</b>
                            TRU64 UNIX ABI
                     <b>ELFOSABI_ARM</b>
                            ARM architecture ABI
                     <b>ELFOSABI_STANDALONE</b>
                            Stand-alone (embedded) ABI

              <b>EI_ABIVERSION</b>
                     The ninth byte identifies the version of the ABI to
                     which the object is targeted.  This field is used
                     to distinguish among incompatible versions of an
                     ABI.  The interpretation of this version number is
                     dependent on the ABI identified by the <b>EI_OSABI</b>
                     field.  Applications conforming to this
                     specification use the value 0.

              <b>EI_PAD </b>Start of padding.  These bytes are reserved and set
                     to zero.  Programs which read them should ignore
                     them.  The value for <b>EI_PAD </b>will change in the
                     future if currently unused bytes are given
                     meanings.

              <b>EI_NIDENT</b>
                     The size of the <i>e_ident</i> array.

       <i>e_type</i> This member of the structure identifies the object file
              type:

              <b>ET_NONE</b>
                     An unknown type.
              <b>ET_REL </b>A relocatable file.
              <b>ET_EXEC</b>
                     An executable file.
              <b>ET_DYN </b>A shared object.
              <b>ET_CORE</b>
                     A core file.

       <i>e_machine</i>
              This member specifies the required architecture for an
              individual file.  For example:

              <b>EM_NONE</b>
                     An unknown machine
              <b>EM_M32 </b>AT&amp;T WE 32100
              <b>EM_SPARC</b>
                     Sun Microsystems SPARC
              <b>EM_386 </b>Intel 80386
              <b>EM_68K </b>Motorola 68000
              <b>EM_88K </b>Motorola 88000
              <b>EM_860 </b>Intel 80860
              <b>EM_MIPS</b>
                     MIPS RS3000 (big-endian only)
              <b>EM_PARISC</b>
                     HP/PA
              <b>EM_SPARC32PLUS</b>
                     SPARC with enhanced instruction set
              <b>EM_PPC </b>PowerPC
              <b>EM_PPC64</b>
                     PowerPC 64-bit
              <b>EM_S390</b>
                     IBM S/390
              <b>EM_ARM </b>Advanced RISC Machines
              <b>EM_SH  </b>Renesas SuperH
              <b>EM_SPARCV9</b>
                     SPARC v9 64-bit
              <b>EM_IA_64</b>
                     Intel Itanium
              <b>EM_X86_64</b>
                     AMD x86-64
              <b>EM_VAX </b>DEC Vax

       <i>e_version</i>
              This member identifies the file version:

              <b>EV_NONE</b>
                     Invalid version
              <b>EV_CURRENT</b>
                     Current version

       <i>e_entry</i>
              This member gives the virtual address to which the system
              first transfers control, thus starting the process.  If
              the file has no associated entry point, this member holds
              zero.

       <i>e_phoff</i>
              This member holds the program header table's file offset
              in bytes.  If the file has no program header table, this
              member holds zero.

       <i>e_shoff</i>
              This member holds the section header table's file offset
              in bytes.  If the file has no section header table, this
              member holds zero.

       <i>e_flags</i>
              This member holds processor-specific flags associated with
              the file.  Flag names take the form EF_`machine_flag'.
              Currently, no flags have been defined.

       <i>e_ehsize</i>
              This member holds the ELF header's size in bytes.

       <i>e_phentsize</i>
              This member holds the size in bytes of one entry in the
              file's program header table; all entries are the same
              size.

       <i>e_phnum</i>
              This member holds the number of entries in the program
              header table.  Thus the product of <i>e_phentsize</i> and <i>e_phnum</i>
              gives the table's size in bytes.  If a file has no program
              header, <i>e_phnum</i> holds the value zero.

              If the number of entries in the program header table is
              larger than or equal to <b>PN_XNUM </b>(0xffff), this member
              holds <b>PN_XNUM </b>(0xffff) and the real number of entries in
              the program header table is held in the <i>sh_info</i> member of
              the initial entry in section header table.  Otherwise, the
              <i>sh_info</i> member of the initial entry contains the value
              zero.

              <b>PN_XNUM</b>
                     This is defined as 0xffff, the largest number
                     <i>e_phnum</i> can have, specifying where the actual
                     number of program headers is assigned.

       <i>e_shentsize</i>
              This member holds a sections header's size in bytes.  A
              section header is one entry in the section header table;
              all entries are the same size.

       <i>e_shnum</i>
              This member holds the number of entries in the section
              header table.  Thus the product of <i>e_shentsize</i> and <i>e_shnum</i>
              gives the section header table's size in bytes.  If a file
              has no section header table, <i>e_shnum</i> holds the value of
              zero.

              If the number of entries in the section header table is
              larger than or equal to <b>SHN_LORESERVE </b>(0xff00), <i>e_shnum</i>
              holds the value zero and the real number of entries in the
              section header table is held in the <i>sh_size</i> member of the
              initial entry in section header table.  Otherwise, the
              <i>sh_size</i> member of the initial entry in the section header
              table holds the value zero.

       <i>e_shstrndx</i>
              This member holds the section header table index of the
              entry associated with the section name string table.  If
              the file has no section name string table, this member
              holds the value <b>SHN_UNDEF</b>.

              If the index of section name string table section is
              larger than or equal to <b>SHN_LORESERVE </b>(0xff00), this
              member holds <b>SHN_XINDEX </b>(0xffff) and the real index of the
              section name string table section is held in the <i>sh_link</i>
              member of the initial entry in section header table.
              Otherwise, the <i>sh_link</i> member of the initial entry in
              section header table contains the value zero.

   <b>Program header (Phdr)</b>
       An executable or shared object file's program header table is an
       array of structures, each describing a segment or other
       information the system needs to prepare the program for
       execution.  An object file <i>segment</i> contains one or more <i>sections</i>.
       Program headers are meaningful only for executable and shared
       object files.  A file specifies its own program header size with
       the ELF header's <i>e_phentsize</i> and <i>e_phnum</i> members.  The ELF
       program header is described by the type <i>Elf32_Phdr</i> or <i>Elf64_Phdr</i>
       depending on the architecture:

           typedef struct {
               uint32_t   p_type;
               Elf32_Off  p_offset;
               Elf32_Addr p_vaddr;
               Elf32_Addr p_paddr;
               uint32_t   p_filesz;
               uint32_t   p_memsz;
               uint32_t   p_flags;
               uint32_t   p_align;
           } Elf32_Phdr;

           typedef struct {
               uint32_t   p_type;
               uint32_t   p_flags;
               Elf64_Off  p_offset;
               Elf64_Addr p_vaddr;
               Elf64_Addr p_paddr;
               uint64_t   p_filesz;
               uint64_t   p_memsz;
               uint64_t   p_align;
           } Elf64_Phdr;

       The main difference between the 32-bit and the 64-bit program
       header lies in the location of the <i>p_flags</i> member in the total
       struct.

       <i>p_type</i> This member of the structure indicates what kind of
              segment this array element describes or how to interpret
              the array element's information.

                 <b>PT_NULL</b>
                        The array element is unused and the other
                        members' values are undefined.  This lets the
                        program header have ignored entries.

                 <b>PT_LOAD</b>
                        The array element specifies a loadable segment,
                        described by <i>p_filesz</i> and <i>p_memsz</i>.  The bytes
                        from the file are mapped to the beginning of the
                        memory segment.  If the segment's memory size
                        <i>p_memsz</i> is larger than the file size <i>p_filesz</i>,
                        the "extra" bytes are defined to hold the value
                        0 and to follow the segment's initialized area.
                        The file size may not be larger than the memory
                        size.  Loadable segment entries in the program
                        header table appear in ascending order, sorted
                        on the <i>p_vaddr</i> member.

                 <b>PT_DYNAMIC</b>
                        The array element specifies dynamic linking
                        information.

                 <b>PT_INTERP</b>
                        The array element specifies the location and
                        size of a null-terminated pathname to invoke as
                        an interpreter.  This segment type is meaningful
                        only for executable files (though it may occur
                        for shared objects).  However it may not occur
                        more than once in a file.  If it is present, it
                        must precede any loadable segment entry.

                 <b>PT_NOTE</b>
                        The array element specifies the location of
                        notes (ElfN_Nhdr).

                 <b>PT_SHLIB</b>
                        This segment type is reserved but has
                        unspecified semantics.  Programs that contain an
                        array element of this type do not conform to the
                        ABI.

                 <b>PT_PHDR</b>
                        The array element, if present, specifies the
                        location and size of the program header table
                        itself, both in the file and in the memory image
                        of the program.  This segment type may not occur
                        more than once in a file.  Moreover, it may
                        occur only if the program header table is part
                        of the memory image of the program.  If it is
                        present, it must precede any loadable segment
                        entry.

                 <b>PT_LOPROC</b>, <b>PT_HIPROC</b>
                        Values in the inclusive range [<b>PT_LOPROC</b>,
                        <b>PT_HIPROC</b>] are reserved for processor-specific
                        semantics.

                 <b>PT_GNU_STACK</b>
                        GNU extension which is used by the Linux kernel
                        to control the state of the stack via the flags
                        set in the <i>p_flags</i> member.

       <i>p_offset</i>
              This member holds the offset from the beginning of the
              file at which the first byte of the segment resides.

       <i>p_vaddr</i>
              This member holds the virtual address at which the first
              byte of the segment resides in memory.

       <i>p_paddr</i>
              On systems for which physical addressing is relevant, this
              member is reserved for the segment's physical address.
              Under BSD this member is not used and must be zero.

       <i>p_filesz</i>
              This member holds the number of bytes in the file image of
              the segment.  It may be zero.

       <i>p_memsz</i>
              This member holds the number of bytes in the memory image
              of the segment.  It may be zero.

       <i>p_flags</i>
              This member holds a bit mask of flags relevant to the
              segment:

              <b>PF_X   </b>An executable segment.
              <b>PF_W   </b>A writable segment.
              <b>PF_R   </b>A readable segment.

              A text segment commonly has the flags <b>PF_X </b>and <b>PF_R</b>.  A
              data segment commonly has <b>PF_W </b>and <b>PF_R</b>.

       <i>p_align</i>
              This member holds the value to which the segments are
              aligned in memory and in the file.  Loadable process
              segments must have congruent values for <i>p_vaddr</i> and
              <i>p_offset</i>, modulo the page size.  Values of zero and one
              mean no alignment is required.  Otherwise, <i>p_align</i> should
              be a positive, integral power of two, and <i>p_vaddr</i> should
              equal <i>p_offset</i>, modulo <i>p_align</i>.

   <b>Section header (Shdr)</b>
       A file's section header table lets one locate all the file's
       sections.  The section header table is an array of <i>Elf32_Shdr</i> or
       <i>Elf64_Shdr</i> structures.  The ELF header's <i>e_shoff</i> member gives the
       byte offset from the beginning of the file to the section header
       table.  <i>e_shnum</i> holds the number of entries the section header
       table contains.  <i>e_shentsize</i> holds the size in bytes of each
       entry.

       A section header table index is a subscript into this array.
       Some section header table indices are reserved: the initial entry
       and the indices between <b>SHN_LORESERVE </b>and <b>SHN_HIRESERVE</b>.  The
       initial entry is used in ELF extensions for <i>e_phnum</i>, <i>e_shnum</i>, and
       <i>e_shstrndx</i>; in other cases, each field in the initial entry is
       set to zero.  An object file does not have sections for these
       special indices:

       <b>SHN_UNDEF</b>
              This value marks an undefined, missing, irrelevant, or
              otherwise meaningless section reference.

       <b>SHN_LORESERVE</b>
              This value specifies the lower bound of the range of
              reserved indices.

       <b>SHN_LOPROC</b>, <b>SHN_HIPROC</b>
              Values greater in the inclusive range [<b>SHN_LOPROC</b>,
              <b>SHN_HIPROC</b>] are reserved for processor-specific semantics.

       <b>SHN_ABS</b>
              This value specifies the absolute value for the
              corresponding reference.  For example, a symbol defined
              relative to section number <b>SHN_ABS </b>has an absolute value
              and is not affected by relocation.

       <b>SHN_COMMON</b>
              Symbols defined relative to this section are common
              symbols, such as FORTRAN COMMON or unallocated C external
              variables.

       <b>SHN_HIRESERVE</b>
              This value specifies the upper bound of the range of
              reserved indices.  The system reserves indices between
              <b>SHN_LORESERVE </b>and <b>SHN_HIRESERVE</b>, inclusive.  The section
              header table does not contain entries for the reserved
              indices.

       The section header has the following structure:

           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint32_t   sh_flags;
               Elf32_Addr sh_addr;
               Elf32_Off  sh_offset;
               uint32_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint32_t   sh_addralign;
               uint32_t   sh_entsize;
           } Elf32_Shdr;

           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint64_t   sh_flags;
               Elf64_Addr sh_addr;
               Elf64_Off  sh_offset;
               uint64_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint64_t   sh_addralign;
               uint64_t   sh_entsize;
           } Elf64_Shdr;

       No real differences exist between the 32-bit and 64-bit section
       headers.

       <i>sh_name</i>
              This member specifies the name of the section.  Its value
              is an index into the section header string table section,
              giving the location of a null-terminated string.

       <i>sh_type</i>
              This member categorizes the section's contents and
              semantics.

              <b>SHT_NULL</b>
                     This value marks the section header as inactive.
                     It does not have an associated section.  Other
                     members of the section header have undefined
                     values.

              <b>SHT_PROGBITS</b>
                     This section holds information defined by the
                     program, whose format and meaning are determined
                     solely by the program.

              <b>SHT_SYMTAB</b>
                     This section holds a symbol table.  Typically,
                     <b>SHT_SYMTAB </b>provides symbols for link editing,
                     though it may also be used for dynamic linking.  As
                     a complete symbol table, it may contain many
                     symbols unnecessary for dynamic linking.  An object
                     file can also contain a <b>SHT_DYNSYM </b>section.

              <b>SHT_STRTAB</b>
                     This section holds a string table.  An object file
                     may have multiple string table sections.

              <b>SHT_RELA</b>
                     This section holds relocation entries with explicit
                     addends, such as type <i>Elf32_Rela</i> for the 32-bit
                     class of object files.  An object may have multiple
                     relocation sections.

              <b>SHT_HASH</b>
                     This section holds a symbol hash table.  An object
                     participating in dynamic linking must contain a
                     symbol hash table.  An object file may have only
                     one hash table.

              <b>SHT_DYNAMIC</b>
                     This section holds information for dynamic linking.
                     An object file may have only one dynamic section.

              <b>SHT_NOTE</b>
                     This section holds notes (ElfN_Nhdr).

              <b>SHT_NOBITS</b>
                     A section of this type occupies no space in the
                     file but otherwise resembles <b>SHT_PROGBITS</b>.
                     Although this section contains no bytes, the
                     <i>sh_offset</i> member contains the conceptual file
                     offset.

              <b>SHT_REL</b>
                     This section holds relocation offsets without
                     explicit addends, such as type <i>Elf32_Rel</i> for the
                     32-bit class of object files.  An object file may
                     have multiple relocation sections.

              <b>SHT_SHLIB</b>
                     This section is reserved but has unspecified
                     semantics.

              <b>SHT_DYNSYM</b>
                     This section holds a minimal set of dynamic linking
                     symbols.  An object file can also contain a
                     <b>SHT_SYMTAB </b>section.

              <b>SHT_LOPROC</b>, <b>SHT_HIPROC</b>
                     Values in the inclusive range [<b>SHT_LOPROC</b>,
                     <b>SHT_HIPROC</b>] are reserved for processor-specific
                     semantics.

              <b>SHT_LOUSER</b>
                     This value specifies the lower bound of the range
                     of indices reserved for application programs.

              <b>SHT_HIUSER</b>
                     This value specifies the upper bound of the range
                     of indices reserved for application programs.
                     Section types between <b>SHT_LOUSER </b>and <b>SHT_HIUSER </b>may
                     be used by the application, without conflicting
                     with current or future system-defined section
                     types.

       <i>sh_flags</i>
              Sections support one-bit flags that describe miscellaneous
              attributes.  If a flag bit is set in <i>sh_flags</i>, the
              attribute is "on" for the section.  Otherwise, the
              attribute is "off" or does not apply.  Undefined
              attributes are set to zero.

              <b>SHF_WRITE</b>
                     This section contains data that should be writable
                     during process execution.

              <b>SHF_ALLOC</b>
                     This section occupies memory during process
                     execution.  Some control sections do not reside in
                     the memory image of an object file.  This attribute
                     is off for those sections.

              <b>SHF_EXECINSTR</b>
                     This section contains executable machine
                     instructions.

              <b>SHF_MASKPROC</b>
                     All bits included in this mask are reserved for
                     processor-specific semantics.

       <i>sh_addr</i>
              If this section appears in the memory image of a process,
              this member holds the address at which the section's first
              byte should reside.  Otherwise, the member contains zero.

       <i>sh_offset</i>
              This member's value holds the byte offset from the
              beginning of the file to the first byte in the section.
              One section type, <b>SHT_NOBITS</b>, occupies no space in the
              file, and its <i>sh_offset</i> member locates the conceptual
              placement in the file.

       <i>sh_size</i>
              This member holds the section's size in bytes.  Unless the
              section type is <b>SHT_NOBITS</b>, the section occupies <i>sh_size</i>
              bytes in the file.  A section of type <b>SHT_NOBITS </b>may have
              a nonzero size, but it occupies no space in the file.

       <i>sh_link</i>
              This member holds a section header table index link, whose
              interpretation depends on the section type.

       <i>sh_info</i>
              This member holds extra information, whose interpretation
              depends on the section type.

       <i>sh_addralign</i>
              Some sections have address alignment constraints.  If a
              section holds a doubleword, the system must ensure
              doubleword alignment for the entire section.  That is, the
              value of <i>sh_addr</i> must be congruent to zero, modulo the
              value of <i>sh_addralign</i>.  Only zero and positive integral
              powers of two are allowed.  The value 0 or 1 means that
              the section has no alignment constraints.

       <i>sh_entsize</i>
              Some sections hold a table of fixed-sized entries, such as
              a symbol table.  For such a section, this member gives the
              size in bytes for each entry.  This member contains zero
              if the section does not hold a table of fixed-size
              entries.

       Various sections hold program and control information:

       <i>.bss</i>   This section holds uninitialized data that contributes to
              the program's memory image.  By definition, the system
              initializes the data with zeros when the program begins to
              run.  This section is of type <b>SHT_NOBITS</b>.  The attribute
              types are <b>SHF_ALLOC </b>and <b>SHF_WRITE</b>.

       <i>.comment</i>
              This section holds version control information.  This
              section is of type <b>SHT_PROGBITS</b>.  No attribute types are
              used.

       <i>.ctors</i> This section holds initialized pointers to the C++
              constructor functions.  This section is of type
              <b>SHT_PROGBITS</b>.  The attribute types are <b>SHF_ALLOC </b>and
              <b>SHF_WRITE</b>.

       <i>.data</i>  This section holds initialized data that contribute to the
              program's memory image.  This section is of type
              <b>SHT_PROGBITS</b>.  The attribute types are <b>SHF_ALLOC </b>and
              <b>SHF_WRITE</b>.

       <i>.data1</i> This section holds initialized data that contribute to the
              program's memory image.  This section is of type
              <b>SHT_PROGBITS</b>.  The attribute types are <b>SHF_ALLOC </b>and
              <b>SHF_WRITE</b>.

       <i>.debug</i> This section holds information for symbolic debugging.
              The contents are unspecified.  This section is of type
              <b>SHT_PROGBITS</b>.  No attribute types are used.

       <i>.dtors</i> This section holds initialized pointers to the C++
              destructor functions.  This section is of type
              <b>SHT_PROGBITS</b>.  The attribute types are <b>SHF_ALLOC </b>and
              <b>SHF_WRITE</b>.

       <i>.dynamic</i>
              This section holds dynamic linking information.  The
              section's attributes will include the <b>SHF_ALLOC </b>bit.
              Whether the <b>SHF_WRITE </b>bit is set is processor-specific.
              This section is of type <b>SHT_DYNAMIC</b>.  See the attributes
              above.

       <i>.dynstr</i>
              This section holds strings needed for dynamic linking,
              most commonly the strings that represent the names
              associated with symbol table entries.  This section is of
              type <b>SHT_STRTAB</b>.  The attribute type used is <b>SHF_ALLOC</b>.

       <i>.dynsym</i>
              This section holds the dynamic linking symbol table.  This
              section is of type <b>SHT_DYNSYM</b>.  The attribute used is
              <b>SHF_ALLOC</b>.

       <i>.fini</i>  This section holds executable instructions that contribute
              to the process termination code.  When a program exits
              normally the system arranges to execute the code in this
              section.  This section is of type <b>SHT_PROGBITS</b>.  The
              attributes used are <b>SHF_ALLOC </b>and <b>SHF_EXECINSTR</b>.

       <i>.gnu.version</i>
              This section holds the version symbol table, an array of
              <i>ElfN_Half</i> elements.  This section is of type
              <b>SHT_GNU_versym</b>.  The attribute type used is <b>SHF_ALLOC</b>.

       <i>.gnu.version_d</i>
              This section holds the version symbol definitions, a table
              of <i>ElfN_Verdef</i> structures.  This section is of type
              <b>SHT_GNU_verdef</b>.  The attribute type used is <b>SHF_ALLOC</b>.

       <i>.gnu.version_r</i>
              This section holds the version symbol needed elements, a
              table of <i>ElfN_Verneed</i> structures.  This section is of type
              <b>SHT_GNU_versym</b>.  The attribute type used is <b>SHF_ALLOC</b>.

       <i>.got</i>   This section holds the global offset table.  This section
              is of type <b>SHT_PROGBITS</b>.  The attributes are processor-
              specific.

       <i>.hash</i>  This section holds a symbol hash table.  This section is
              of type <b>SHT_HASH</b>.  The attribute used is <b>SHF_ALLOC</b>.

       <i>.init</i>  This section holds executable instructions that contribute
              to the process initialization code.  When a program starts
              to run the system arranges to execute the code in this
              section before calling the main program entry point.  This
              section is of type <b>SHT_PROGBITS</b>.  The attributes used are
              <b>SHF_ALLOC </b>and <b>SHF_EXECINSTR</b>.

       <i>.interp</i>
              This section holds the pathname of a program interpreter.
              If the file has a loadable segment that includes the
              section, the section's attributes will include the
              <b>SHF_ALLOC </b>bit.  Otherwise, that bit will be off.  This
              section is of type <b>SHT_PROGBITS</b>.

       <i>.line</i>  This section holds line number information for symbolic
              debugging, which describes the correspondence between the
              program source and the machine code.  The contents are
              unspecified.  This section is of type <b>SHT_PROGBITS</b>.  No
              attribute types are used.

       <i>.note</i>  This section holds various notes.  This section is of type
              <b>SHT_NOTE</b>.  No attribute types are used.

       <i>.note.ABI-tag</i>
              This section is used to declare the expected run-time ABI
              of the ELF image.  It may include the operating system
              name and its run-time versions.  This section is of type
              <b>SHT_NOTE</b>.  The only attribute used is <b>SHF_ALLOC</b>.

       <i>.note.gnu.build-id</i>
              This section is used to hold an ID that uniquely
              identifies the contents of the ELF image.  Different files
              with the same build ID should contain the same executable
              content.  See the <b>--build-id </b>option to the GNU linker (<b>ld</b>
              (1)) for more details.  This section is of type <b>SHT_NOTE</b>.
              The only attribute used is <b>SHF_ALLOC</b>.

       <i>.note.GNU-stack</i>
              This section is used in Linux object files for declaring
              stack attributes.  This section is of type <b>SHT_PROGBITS</b>.
              The only attribute used is <b>SHF_EXECINSTR</b>.  This indicates
              to the GNU linker that the object file requires an
              executable stack.

       <i>.note.openbsd.ident</i>
              OpenBSD native executables usually contain this section to
              identify themselves so the kernel can bypass any
              compatibility ELF binary emulation tests when loading the
              file.

       <i>.plt</i>   This section holds the procedure linkage table.  This
              section is of type <b>SHT_PROGBITS</b>.  The attributes are
              processor-specific.

       <i>.relNAME</i>
              This section holds relocation information as described
              below.  If the file has a loadable segment that includes
              relocation, the section's attributes will include the
              <b>SHF_ALLOC </b>bit.  Otherwise, the bit will be off.  By
              convention, "NAME" is supplied by the section to which the
              relocations apply.  Thus a relocation section for <b>.text</b>
              normally would have the name <b>.rel.text</b>.  This section is
              of type <b>SHT_REL</b>.

       <i>.relaNAME</i>
              This section holds relocation information as described
              below.  If the file has a loadable segment that includes
              relocation, the section's attributes will include the
              <b>SHF_ALLOC </b>bit.  Otherwise, the bit will be off.  By
              convention, "NAME" is supplied by the section to which the
              relocations apply.  Thus a relocation section for <b>.text</b>
              normally would have the name <b>.rela.text</b>.  This section is
              of type <b>SHT_RELA</b>.

       <i>.rodata</i>
              This section holds read-only data that typically
              contributes to a nonwritable segment in the process image.
              This section is of type <b>SHT_PROGBITS</b>.  The attribute used
              is <b>SHF_ALLOC</b>.

       <i>.rodata1</i>
              This section holds read-only data that typically
              contributes to a nonwritable segment in the process image.
              This section is of type <b>SHT_PROGBITS</b>.  The attribute used
              is <b>SHF_ALLOC</b>.

       <i>.shstrtab</i>
              This section holds section names.  This section is of type
              <b>SHT_STRTAB</b>.  No attribute types are used.

       <i>.strtab</i>
              This section holds strings, most commonly the strings that
              represent the names associated with symbol table entries.
              If the file has a loadable segment that includes the
              symbol string table, the section's attributes will include
              the <b>SHF_ALLOC </b>bit.  Otherwise, the bit will be off.  This
              section is of type <b>SHT_STRTAB</b>.

       <i>.symtab</i>
              This section holds a symbol table.  If the file has a
              loadable segment that includes the symbol table, the
              section's attributes will include the <b>SHF_ALLOC </b>bit.
              Otherwise, the bit will be off.  This section is of type
              <b>SHT_SYMTAB</b>.

       <i>.text</i>  This section holds the "text", or executable instructions,
              of a program.  This section is of type <b>SHT_PROGBITS</b>.  The
              attributes used are <b>SHF_ALLOC </b>and <b>SHF_EXECINSTR</b>.

   <b>String and symbol tables</b>
       String table sections hold null-terminated character sequences,
       commonly called strings.  The object file uses these strings to
       represent symbol and section names.  One references a string as
       an index into the string table section.  The first byte, which is
       index zero, is defined to hold a null byte ('\0').  Similarly, a
       string table's last byte is defined to hold a null byte, ensuring
       null termination for all strings.

       An object file's symbol table holds information needed to locate
       and relocate a program's symbolic definitions and references.  A
       symbol table index is a subscript into this array.

           typedef struct {
               uint32_t      st_name;
               Elf32_Addr    st_value;
               uint32_t      st_size;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
           } Elf32_Sym;

           typedef struct {
               uint32_t      st_name;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
               Elf64_Addr    st_value;
               uint64_t      st_size;
           } Elf64_Sym;

       The 32-bit and 64-bit versions have the same members, just in a
       different order.

       <i>st_name</i>
              This member holds an index into the object file's symbol
              string table, which holds character representations of the
              symbol names.  If the value is nonzero, it represents a
              string table index that gives the symbol name.  Otherwise,
              the symbol has no name.

       <i>st_value</i>
              This member gives the value of the associated symbol.

       <i>st_size</i>
              Many symbols have associated sizes.  This member holds
              zero if the symbol has no size or an unknown size.

       <i>st_info</i>
              This member specifies the symbol's type and binding
              attributes:

              <b>STT_NOTYPE</b>
                     The symbol's type is not defined.

              <b>STT_OBJECT</b>
                     The symbol is associated with a data object.

              <b>STT_FUNC</b>
                     The symbol is associated with a function or other
                     executable code.

              <b>STT_SECTION</b>
                     The symbol is associated with a section.  Symbol
                     table entries of this type exist primarily for
                     relocation and normally have <b>STB_LOCAL </b>bindings.

              <b>STT_FILE</b>
                     By convention, the symbol's name gives the name of
                     the source file associated with the object file.  A
                     file symbol has <b>STB_LOCAL </b>bindings, its section
                     index is <b>SHN_ABS</b>, and it precedes the other
                     <b>STB_LOCAL </b>symbols of the file, if it is present.

              <b>STT_LOPROC</b>, <b>STT_HIPROC</b>
                     Values in the inclusive range [<b>STT_LOPROC</b>,
                     <b>STT_HIPROC</b>] are reserved for processor-specific
                     semantics.

              <b>STB_LOCAL</b>
                     Local symbols are not visible outside the object
                     file containing their definition.  Local symbols of
                     the same name may exist in multiple files without
                     interfering with each other.

              <b>STB_GLOBAL</b>
                     Global symbols are visible to all object files
                     being combined.  One file's definition of a global
                     symbol will satisfy another file's undefined
                     reference to the same symbol.

              <b>STB_WEAK</b>
                     Weak symbols resemble global symbols, but their
                     definitions have lower precedence.

              <b>STB_LOPROC</b>, <b>STB_HIPROC</b>
                     Values in the inclusive range [<b>STB_LOPROC</b>,
                     <b>STB_HIPROC</b>] are reserved for processor-specific
                     semantics.

              There are macros for packing and unpacking the binding and
              type fields:

              <b>ELF32_ST_BIND(</b><i>info</i><b>)</b>, <b>ELF64_ST_BIND(</b><i>info</i><b>)</b>
                     Extract a binding from an <i>st_info</i> value.

              <b>ELF32_ST_TYPE(</b><i>info</i><b>)</b>, <b>ELF64_ST_TYPE(</b><i>info</i><b>)</b>
                     Extract a type from an <i>st_info</i> value.

              <b>ELF32_ST_INFO(</b><i>bind</i><b>, </b><i>type</i><b>)</b>, <b>ELF64_ST_INFO(</b><i>bind</i><b>, </b><i>type</i><b>)</b>
                     Convert a binding and a type into an <i>st_info</i> value.

       <i>st_other</i>
              This member defines the symbol visibility.

              <b>STV_DEFAULT</b>
                     Default symbol visibility rules.  Global and weak
                     symbols are available to other modules; references
                     in the local module can be interposed by
                     definitions in other modules.
              <b>STV_INTERNAL</b>
                     Processor-specific hidden class.
              <b>STV_HIDDEN</b>
                     Symbol is unavailable to other modules; references
                     in the local module always resolve to the local
                     symbol (i.e., the symbol can't be interposed by
                     definitions in other modules).
              <b>STV_PROTECTED</b>
                     Symbol is available to other modules, but
                     references in the local module always resolve to
                     the local symbol.

              There are macros for extracting the visibility type:

              <b>ELF32_ST_VISIBILITY</b>(other) or <b>ELF64_ST_VISIBILITY</b>(other)

       <i>st_shndx</i>
              Every symbol table entry is "defined" in relation to some
              section.  This member holds the relevant section header
              table index.

   <b>Relocation entries (Rel &amp; Rela)</b>
       Relocation is the process of connecting symbolic references with
       symbolic definitions.  Relocatable files must have information
       that describes how to modify their section contents, thus
       allowing executable and shared object files to hold the right
       information for a process's program image.  Relocation entries
       are these data.

       Relocation structures that do not need an addend:

           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
           } Elf32_Rel;

           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
           } Elf64_Rel;

       Relocation structures that need an addend:

           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
               int32_t    r_addend;
           } Elf32_Rela;

           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
               int64_t    r_addend;
           } Elf64_Rela;

       <i>r_offset</i>
              This member gives the location at which to apply the
              relocation action.  For a relocatable file, the value is
              the byte offset from the beginning of the section to the
              storage unit affected by the relocation.  For an
              executable file or shared object, the value is the virtual
              address of the storage unit affected by the relocation.

       <i>r_info</i> This member gives both the symbol table index with respect
              to which the relocation must be made and the type of
              relocation to apply.  Relocation types are processor-
              specific.  When the text refers to a relocation entry's
              relocation type or symbol table index, it means the result
              of applying <b>ELF[32|64]_R_TYPE </b>or <b>ELF[32|64]_R_SYM</b>,
              respectively, to the entry's <i>r_info</i> member.

       <i>r_addend</i>
              This member specifies a constant addend used to compute
              the value to be stored into the relocatable field.

   <b>Dynamic tags (Dyn)</b>
       The <i>.dynamic</i> section contains a series of structures that hold
       relevant dynamic linking information.  The <i>d_tag</i> member controls
       the interpretation of <i>d_un</i>.

           typedef struct {
               Elf32_Sword    d_tag;
               union {
                   Elf32_Word d_val;
                   Elf32_Addr d_ptr;
               } d_un;
           } Elf32_Dyn;
           extern Elf32_Dyn _DYNAMIC[];

           typedef struct {
               Elf64_Sxword    d_tag;
               union {
                   Elf64_Xword d_val;
                   Elf64_Addr  d_ptr;
               } d_un;
           } Elf64_Dyn;
           extern Elf64_Dyn _DYNAMIC[];

       <i>d_tag</i>  This member may have any of the following values:

              <b>DT_NULL</b>
                     Marks end of dynamic section

              <b>DT_NEEDED</b>
                     String table offset to name of a needed library

              <b>DT_PLTRELSZ</b>
                     Size in bytes of PLT relocation entries

              <b>DT_PLTGOT</b>
                     Address of PLT and/or GOT

              <b>DT_HASH</b>
                     Address of symbol hash table

              <b>DT_STRTAB</b>
                     Address of string table

              <b>DT_SYMTAB</b>
                     Address of symbol table

              <b>DT_RELA</b>
                     Address of Rela relocation table

              <b>DT_RELASZ</b>
                     Size in bytes of the Rela relocation table

              <b>DT_RELAENT</b>
                     Size in bytes of a Rela relocation table entry

              <b>DT_STRSZ</b>
                     Size in bytes of string table

              <b>DT_SYMENT</b>
                     Size in bytes of a symbol table entry

              <b>DT_INIT</b>
                     Address of the initialization function

              <b>DT_FINI</b>
                     Address of the termination function

              <b>DT_SONAME</b>
                     String table offset to name of shared object

              <b>DT_RPATH</b>
                     String table offset to library search path
                     (deprecated)

              <b>DT_SYMBOLIC</b>
                     Alert linker to search this shared object before
                     the executable for symbols

              <b>DT_REL </b>Address of Rel relocation table

              <b>DT_RELSZ</b>
                     Size in bytes of Rel relocation table

              <b>DT_RELENT</b>
                     Size in bytes of a Rel table entry

              <b>DT_PLTREL</b>
                     Type of relocation entry to which the PLT refers
                     (Rela or Rel)

              <b>DT_DEBUG</b>
                     Undefined use for debugging

              <b>DT_TEXTREL</b>
                     Absence of this entry indicates that no relocation
                     entries should apply to a nonwritable segment

              <b>DT_JMPREL</b>
                     Address of relocation entries associated solely
                     with the PLT

              <b>DT_BIND_NOW</b>
                     Instruct dynamic linker to process all relocations
                     before transferring control to the executable

              <b>DT_RUNPATH</b>
                     String table offset to library search path

              <b>DT_LOPROC</b>, <b>DT_HIPROC</b>
                     Values in the inclusive range [<b>DT_LOPROC</b>,
                     <b>DT_HIPROC</b>] are reserved for processor-specific
                     semantics

       <i>d_val</i>  This member represents integer values with various
              interpretations.

       <i>d_ptr</i>  This member represents program virtual addresses.  When
              interpreting these addresses, the actual address should be
              computed based on the original file value and memory base
              address.  Files do not contain relocation entries to fixup
              these addresses.

       <i>_DYNAMIC</i>
              Array containing all the dynamic structures in the
              <i>.dynamic</i> section.  This is automatically populated by the
              linker.

   <b>Notes (Nhdr)</b>
       ELF notes allow for appending arbitrary information for the
       system to use.  They are largely used by core files (<i>e_type</i> of
       <b>ET_CORE</b>), but many projects define their own set of extensions.
       For example, the GNU tool chain uses ELF notes to pass
       information from the linker to the C library.

       Note sections contain a series of notes (see the <i>struct</i>
       definitions below).  Each note is followed by the name field
       (whose length is defined in <i>n_namesz</i>) and then by the descriptor
       field (whose length is defined in <i>n_descsz</i>) and whose starting
       address has a 4 byte alignment.  Neither field is defined in the
       note struct due to their arbitrary lengths.

       An example for parsing out two consecutive notes should clarify
       their layout in memory:

           void *memory, *name, *desc;
           Elf64_Nhdr *note, *next_note;

           /* The buffer is pointing to the start of the section/segment. */
           note = memory;

           /* If the name is defined, it follows the note. */
           name = note-&gt;n_namesz == 0 ? NULL : memory + sizeof(*note);

           /* If the descriptor is defined, it follows the name
              (with alignment). */

           desc = note-&gt;n_descsz == 0 ? NULL :
                  memory + sizeof(*note) + ALIGN_UP(note-&gt;n_namesz, 4);

           /* The next note follows both (with alignment). */
           next_note = memory + sizeof(*note) +
                                ALIGN_UP(note-&gt;n_namesz, 4) +
                                ALIGN_UP(note-&gt;n_descsz, 4);

       Keep in mind that the interpretation of <i>n_type</i> depends on the
       namespace defined by the <i>n_namesz</i> field.  If the <i>n_namesz</i> field
       is not set (e.g., is 0), then there are two sets of notes: one
       for core files and one for all other ELF types.  If the namespace
       is unknown, then tools will usually fallback to these sets of
       notes as well.

           typedef struct {
               Elf32_Word n_namesz;
               Elf32_Word n_descsz;
               Elf32_Word n_type;
           } Elf32_Nhdr;

           typedef struct {
               Elf64_Word n_namesz;
               Elf64_Word n_descsz;
               Elf64_Word n_type;
           } Elf64_Nhdr;

       <i>n_namesz</i>
              The length of the name field in bytes.  The contents will
              immediately follow this note in memory.  The name is null
              terminated.  For example, if the name is "GNU", then
              <i>n_namesz</i> will be set to 4.

       <i>n_descsz</i>
              The length of the descriptor field in bytes.  The contents
              will immediately follow the name field in memory.

       <i>n_type</i> Depending on the value of the name field, this member may
              have any of the following values:

              <b>Core files (e_type = ET_CORE)</b>
                   Notes used by all core files.  These are highly
                   operating system or architecture specific and often
                   require close coordination with kernels, C libraries,
                   and debuggers.  These are used when the namespace is
                   the default (i.e., <i>n_namesz</i> will be set to 0), or a
                   fallback when the namespace is unknown.

                   <b>NT_PRSTATUS</b>
                          prstatus struct
                   <b>NT_FPREGSET</b>
                          fpregset struct
                   <b>NT_PRPSINFO</b>
                          prpsinfo struct
                   <b>NT_PRXREG</b>
                          prxregset struct
                   <b>NT_TASKSTRUCT</b>
                          task structure
                   <b>NT_PLATFORM</b>
                          String from sysinfo(SI_PLATFORM)
                   <b>NT_AUXV</b>
                          auxv array
                   <b>NT_GWINDOWS</b>
                          gwindows struct
                   <b>NT_ASRS</b>
                          asrset struct
                   <b>NT_PSTATUS</b>
                          pstatus struct
                   <b>NT_PSINFO</b>
                          psinfo struct
                   <b>NT_PRCRED</b>
                          prcred struct
                   <b>NT_UTSNAME</b>
                          utsname struct
                   <b>NT_LWPSTATUS</b>
                          lwpstatus struct
                   <b>NT_LWPSINFO</b>
                          lwpinfo struct
                   <b>NT_PRFPXREG</b>
                          fprxregset struct
                   <b>NT_SIGINFO</b>
                          siginfo_t (size might increase over time)
                   <b>NT_FILE</b>
                          Contains information about mapped files
                   <b>NT_PRXFPREG</b>
                          user_fxsr_struct
                   <b>NT_PPC_VMX</b>
                          PowerPC Altivec/VMX registers
                   <b>NT_PPC_SPE</b>
                          PowerPC SPE/EVR registers
                   <b>NT_PPC_VSX</b>
                          PowerPC VSX registers
                   <b>NT_386_TLS</b>
                          i386 TLS slots (struct user_desc)
                   <b>NT_386_IOPERM</b>
                          x86 io permission bitmap (1=deny)
                   <b>NT_X86_XSTATE</b>
                          x86 extended state using xsave
                   <b>NT_S390_HIGH_GPRS</b>
                          s390 upper register halves
                   <b>NT_S390_TIMER</b>
                          s390 timer register
                   <b>NT_S390_TODCMP</b>
                          s390 time-of-day (TOD) clock comparator
                          register
                   <b>NT_S390_TODPREG</b>
                          s390 time-of-day (TOD) programmable register
                   <b>NT_S390_CTRS</b>
                          s390 control registers
                   <b>NT_S390_PREFIX</b>
                          s390 prefix register
                   <b>NT_S390_LAST_BREAK</b>
                          s390 breaking event address
                   <b>NT_S390_SYSTEM_CALL</b>
                          s390 system call restart data
                   <b>NT_S390_TDB</b>
                          s390 transaction diagnostic block
                   <b>NT_ARM_VFP</b>
                          ARM VFP/NEON registers
                   <b>NT_ARM_TLS</b>
                          ARM TLS register
                   <b>NT_ARM_HW_BREAK</b>
                          ARM hardware breakpoint registers
                   <b>NT_ARM_HW_WATCH</b>
                          ARM hardware watchpoint registers
                   <b>NT_ARM_SYSTEM_CALL</b>
                          ARM system call number

              <b>n_name = GNU</b>
                   Extensions used by the GNU tool chain.

                   <b>NT_GNU_ABI_TAG</b>
                          Operating system (OS) ABI information.  The
                          desc field will be 4 words:

                           word 0: OS descriptor (<b>ELF_NOTE_OS_LINUX</b>,
                            <b>ELF_NOTE_OS_GNU</b>, and so on)`
                           word 1: major version of the ABI
                           word 2: minor version of the ABI
                           word 3: subminor version of the ABI

                   <b>NT_GNU_HWCAP</b>
                          Synthetic hwcap information.  The desc field
                          begins with two words:

                           word 0: number of entries
                           word 1: bit mask of enabled entries

                          Then follow variable-length entries, one byte
                          followed by a null-terminated hwcap name
                          string.  The byte gives the bit number to test
                          if enabled, (1U &lt;&lt; bit) &amp; bit mask.

                   <b>NT_GNU_BUILD_ID</b>
                          Unique build ID as generated by the GNU <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/ld.1.html">ld(1)</a>
                          <b>--build-id </b>option.  The desc consists of any
                          nonzero number of bytes.

                   <b>NT_GNU_GOLD_VERSION</b>
                          The desc contains the GNU Gold linker version
                          used.

              <b>Default/unknown namespace (e_type != ET_CORE)</b>
                   These are used when the namespace is the default
                   (i.e., <i>n_namesz</i> will be set to 0), or a fallback when
                   the namespace is unknown.

                   <b>NT_VERSION</b>
                          A version string of some sort.
                   <b>NT_ARCH</b>
                          Architecture information.
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       ELF first appeared in System V.  The ELF format is an adopted
       standard.

       The extensions for <i>e_phnum</i>, <i>e_shnum</i>, and <i>e_shstrndx</i> respectively
       are Linux extensions.  Sun, BSD, and AMD64 also support them; for
       further information, look under SEE ALSO.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/as.1.html">as(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/elfedit.1.html">elfedit(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/gdb.1.html">gdb(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/ld.1.html">ld(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/nm.1.html">nm(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/objcopy.1.html">objcopy(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/objdump.1.html">objdump(1)</a>,
       <b>patchelf</b>(1), <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/readelf.1.html">readelf(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/size.1.html">size(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/strings.1.html">strings(1)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man1/strip.1.html">strip(1)</a>,
       <a href="/web/20210330083236/https://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html">dl_iterate_phdr(3)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>, <a href="/web/20210330083236/https://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so(8)</a>

       Hewlett-Packard, <i>Elf-64 Object File Format</i>.

       Santa Cruz Operation, <i>System V Application Binary Interface</i>.

       UNIX System Laboratories, "Object Files", <i>Executable and Linking</i>
       <i>Format (ELF)</i>.

       Sun Microsystems, <i>Linker and Libraries Guide</i>.

       AMD64 ABI Draft, <i>System V Application Binary Interface AMD64</i>
       <i>Architecture Processor Supplement</i>.
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of release 5.11 of the Linux <i>man-pages</i> project.
       A description of the project, information about reporting bugs,
       and the latest version of this page, can be found at
       <a href="https://web.archive.org/web/20210330083236/https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">Linux                          2021-03-22                         ELF(5)</span>
</pre>

<hr class="end-man-text"/>
<p>Pages that refer to this page: 
    <a href="/web/20210330083236/https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html">dl_iterate_phdr(3)</a>,&nbsp; 
    <a href="/web/20210330083236/https://man7.org/linux/man-pages/man3/end.3.html">end(3)</a>,&nbsp; 
    <a href="/web/20210330083236/https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>,&nbsp; 
    <a href="/web/20210330083236/https://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so(8)</a>
</p>
<hr/>

<p class="page-copyright"><a href="/web/20210330083236/https://man7.org/linux/man-pages/man5/elf.5.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer"/>

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2021-03-22
            by <a href="https://web.archive.org/web/20210330083236/https://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="https://web.archive.org/web/20210330083236/https://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://web.archive.org/web/20210330083236/https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="https://web.archive.org/web/20210330083236/https://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="https://web.archive.org/web/20210330083236/https://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="https://web.archive.org/web/20210330083236/https://man7.org/tlpi/"><img src="https://web.archive.org/web/20210330083236im_/https://man7.org/tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI"/></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer"/>



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Default Statcounter code for man7.org/linux/man-pages
http://www.man7.org/linux/man-pages -->
<script type="text/javascript">
var sc_project=7422636;
var sc_invisible=1;
var sc_security="9b6714ff";
</script>
<script type="text/javascript" src="https://web.archive.org/web/20210330083236js_/https://www.statcounter.com/counter/counter.js" async></script>
<noscript><div class="statcounter"><a title="Web Analytics
Made Easy - StatCounter" href="https://web.archive.org/web/20210330083236/https://statcounter.com/" target="_blank"><img class="statcounter" src="https://web.archive.org/web/20210330083236im_/https://c.statcounter.com/7422636/0/9b6714ff/1/" alt="Web Analytics Made Easy -
StatCounter"></a></div></noscript>
<!-- End of Statcounter Code -->



<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://web.archive.org/web/20210330083236/https://ssl' : 'https://web.archive.org/web/20210330083236/http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
<!--
     FILE ARCHIVED ON 08:32:36 Mar 30, 2021 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 22:06:03 Jan 18, 2022.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 400.004
  exclusion.robots: 0.196
  exclusion.robots.policy: 0.18
  RedisCDXSource: 1.488
  esindex: 0.041
  LoadShardBlock: 368.837 (3)
  PetaboxLoader3.datanode: 85.516 (4)
  CDXLines.iter: 24.343 (3)
  PetaboxLoader3.resolve: 280.412 (3)
  load_resource: 75.428
-->